{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>\u26a0\ufe0f Important Notice: This document is AI-generated based on source-code analysis. Although we strive for accuracy, inconsistencies or issues may still exist. We are actively improving and validating all content. If you encounter any problems, please report them promptly.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#problem","title":"Problem","text":"<p>Class that defines a multi-objective optimisation problem.</p> <p>Constructor:</p> <pre><code>Problem(objectives, n_points, region, constraints=[], penalty_weight=1e6)\n</code></pre> <p>Parameters:</p> <ul> <li><code>objectives</code> (list[callable]): List of objective functions. Each function takes coords (n_points, 2) and returns a scalar.</li> <li><code>n_points</code> (int): Number of coordinate points to optimise.</li> <li><code>region</code> (shapely.geometry.Polygon): Shapely polygon defining the feasible region.</li> <li><code>constraints</code> (list, optional): List of constraint functions. Default is an empty list.</li> <li><code>penalty_weight</code> (float, optional): Weight applied to constraint violations. Default is 1e6.</li> </ul> <p>Methods:</p>"},{"location":"api/#sample_populationpop_size","title":"sample_population(pop_size)","text":"<p>Generate an initial population.</p> <p>Parameters:</p> <ul> <li><code>pop_size</code> (int): Population size.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Population array with shape<code>(pop_size, n_points, 2)</code>.</li> </ul>"},{"location":"api/#evaluatepopulation","title":"evaluate(population)","text":"<p>Evaluate the objective values for all individuals in a population.</p> <p>Parameters:</p> <ul> <li><code>population</code> (numpy.ndarray): Population with shape<code>(pop_size, n_points, 2)</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Array of objective values with shape <code>(n_objectives, pop_size)</code>.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2 import Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# Define objective functions\ndef obj1(coords):\n    return np.sum(coords[:, 0])\n\ndef obj2(coords):\n    return np.sum(coords[:, 1])\n\n# Create a problem\nregion = region_from_points([[0, 0], [1, 0], [1, 1], [0, 1]])\nproblem = Problem(objectives=[obj1, obj2], n_points=5, region=region)\n\n# Generate an initial population\npopulation = problem.sample_population(10)\nprint(f\"Population shape: {population.shape}\")  # (10, 5, 2)\n\n# Evaluate the population\nvalues = problem.evaluate(population)  # shape: (n_objectives, pop_size)\nprint(f\"Objective 1 values: {values[0]}\")\nprint(f\"Objective 2 values: {values[1]}\")\n</code></pre>"},{"location":"api/#coordsnsga2","title":"CoordsNSGA2","text":"<p>NSGA-II optimiser for coordinate problems.</p> <p>Constructor:</p> <pre><code>CoordsNSGA2(problem, pop_size, prob_crs, prob_mut, random_seed=42)\n</code></pre> <p>Parameters:</p> <ul> <li><code>problem</code> (Problem): Problem instance.</li> <li><code>pop_size</code> (int): Population size (must be even).</li> <li><code>prob_crs</code> (float): Crossover probability in the range 0-1.</li> <li><code>prob_mut</code> (float): Mutation probability in the range 0-1 or -1.</li> <li><code>random_seed</code> (int, optional): Random seed. Default is 42.</li> </ul> <p>Attributes:</p> <ul> <li><code>P</code>: Current population, shape <code>(pop_size, n_points, 2)</code>.</li> <li><code>values_P</code>: Objective values of the current population, shape <code>(n_objectives, pop_size)</code>.</li> <li><code>P_history</code>: Population history.</li> <li><code>values_history</code>: List of objective-value arrays per generation, each with shape <code>(n_objectives, pop_size)</code>.</li> </ul> <p>Methods:</p>"},{"location":"api/#rungenerations-verbosetrue","title":"run(generations, verbose=True)","text":"<p>Run the optimization algorithm.</p> <p>Parameters:</p> <ul> <li><code>generations</code> (int): Number of generations.</li> <li><code>verbose</code> (bool, optional): Show progress bar if <code>True</code>. Default is <code>True</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Final population.</li> </ul>"},{"location":"api/#savepath","title":"save(path)","text":"<p>Save the optimiser state to a file.</p> <p>Parameters:</p> <ul> <li><code>path</code> (str): File path to save to.s</li> </ul>"},{"location":"api/#loadpath","title":"load(path)","text":"<p>Load the optimiser state from a file.</p> <p>Parameters:</p> <ul> <li><code>path</code> (str): File path to load from.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2 import CoordsNSGA2, Problem\n\n# Create an optimiser\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# Run optimisation\nresult = optimizer.run(1000)\n\n# Save results\noptimizer.save(\"optimization_result.npz\")\n\n# Load results\noptimizer.load(\"optimization_result.npz\")\n</code></pre>"},{"location":"api/#spatial-utilities","title":"Spatial Utilities","text":""},{"location":"api/#region_from_pointspoints","title":"region_from_points(points)","text":"<p>Create a polygon region from a list of points.s</p> <p>Parameters:</p> <ul> <li><code>points</code> (list): List of points in the form <code>[[x1, y1], [x2, y2], ...]</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>shapely.geometry.Polygon</code>: Shapely polygon object.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.spatial import region_from_points\n\n# Create a triangular region\npoints = [[0, 0], [1, 0], [0.5, 1]]\nregion = region_from_points(points)\nprint(f\"Area: {region.area}\")\n</code></pre>"},{"location":"api/#region_from_rangex_min-x_max-y_min-y_max","title":"region_from_range(x_min, x_max, y_min, y_max)","text":"<p>Create a rectangular region from coordinate bounds.</p> <p>Parameters:</p> <ul> <li><code>x_min</code> (float): Minimum x-coordinate.</li> <li><code>x_max</code> (float): Maximum x-coordinate.</li> <li><code>y_min</code> (float): Minimum y-coordinate.</li> <li><code>y_max</code> (float): Maximum y-coordinate.</li> </ul> <p>Returns:</p> <ul> <li><code>shapely.geometry.Polygon</code>: Shapely rectangle object.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.spatial import region_from_range\n\n# Create a rectangular region\nregion = region_from_range(0, 10, 0, 5)\nprint(f\"Bounds: {region.bounds}\")\n</code></pre>"},{"location":"api/#create_points_in_polygonpolygon-n","title":"create_points_in_polygon(polygon, n)","text":"<p>Generate <code>n</code> random points inside a polygon.</p> <p>Parameters:</p> <ul> <li><code>polygon</code> (shapely.geometry.Polygon): Target polygon.</li> <li><code>n</code> (int): Number of points to generate.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Array of coordinates with shape <code>(n, 2)</code>.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.spatial import create_points_in_polygon, region_from_points\n\n# Create a region\nregion = region_from_points([[0, 0], [1, 0], [1, 1], [0, 1]])\n\n# Generate random points\npoints = create_points_in_polygon(region, 10)\nprint(f\"Generated points: {points}\")\n</code></pre>"},{"location":"api/#genetic-operators","title":"Genetic Operators","text":""},{"location":"api/#coords_crossoverpopulation-prob_crs","title":"coords_crossover(population, prob_crs)","text":"<p>Coordinate-specific crossover operator that exchanges subsets of points between parents.</p> <p>Parameters:</p> <ul> <li><code>population</code> (numpy.ndarray): Population with shape <code>(pop_size, n_points, 2)</code>.</li> <li><code>prob_crs</code> (float): Crossover probability.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Population after crossover.</li> </ul> <p>Algorithm:</p> <ul> <li>For each parent pair, perform crossover with probability <code>prob_crs</code>.</li> <li>Randomly select between 1 and <code>n_points-1</code> points to swap.</li> <li>Population size remains unchanged.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.operators.crossover import coords_crossover\n\n# Perform crossover\nnew_population = coords_crossover(population, prob_crs=0.5)\n</code></pre>"},{"location":"api/#coords_mutationpopulation-prob_mut-region","title":"coords_mutation(population, prob_mut, region)","text":"<p>Coordinate-specific mutation operator that relocates points randomly within the region.</p> <p>Parameters:</p> <ul> <li><code>population</code> (numpy.ndarray): Population with shape <code>(pop_size, n_points, 2)</code>.</li> <li><code>prob_mut</code> (float): Mutation probability.</li> <li><code>region</code> (shapely.geometry.Polygon): Feasible region.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Population after mutation.</li> </ul> <p>Algorithm:</p> <ul> <li>For each coordinate point, mutate with probability <code>prob_mut</code>.</li> <li>During mutation, generate a new random position within the region.</li> <li>Ensure mutated points remain inside the feasible region.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.operators.mutation import coords_mutation\n\n# Perform mutation\nnew_population = coords_mutation(population, prob_mut=0.1, region=region)\n</code></pre>"},{"location":"api/#coords_selectionpopulation-values_p-tourn_size3","title":"coords_selection(population, values_P, tourn_size=3)","text":"<p>Tournament selection based on non-dominated sorting and crowding distance.</p> <p>Parameters\uff1a</p> <ul> <li><code>population</code> (numpy.ndarray): Population with shape <code>(pop_size, n_points, 2)</code>.</li> <li><code>values_P</code> (numpy.ndarray): Objective values with shape <code>(n_objectives, pop_size)</code>.</li> <li><code>tourn_size</code> (int, optional): Tournament size. Default is <code>3</code></li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Selected population.</li> </ul> <p>Algorithm:</p> <ul> <li>Use fast non-dominated sorting to assign front ranks.</li> <li>Compute crowding distance within each front.</li> <li>Apply tournament selection, preferring individuals in lower fronts.</li> <li>When ranks tie, choose individuals with larger crowding distance.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.operators.selection import coords_selection\n\n# Perform selection\nselected_population = coords_selection(population, values_P, tourn_size=3)\n</code></pre>"},{"location":"api/#utility-functions","title":"Utility Functions","text":""},{"location":"api/#fast_non_dominated_sortobjectives","title":"fast_non_dominated_sort(objectives)","text":"<p>Fast non-dominated sorting algorithm.</p> <p>Parameters:</p> <ul> <li><code>objectives</code> (numpy.ndarray): Objective values with shape <code>(n_objectives, pop_size)</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code>: List of fronts; each front contains the indices of individuals in that front.</li> </ul> <p>Algorithm:</p> <ul> <li>Count how many times each individual is dominated.</li> <li>Record which individuals each one dominates.</li> <li>Return indices grouped by front.</li> <li>Sort individuals by front rank.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.utils import fast_non_dominated_sort\n\n# Perform non-dominated sorting\nfronts = fast_non_dominated_sort(values)\nprint(f\"Number of fronts: {len(fronts)}\")\nfor i, front in enumerate(fronts):\n    print(f\"Front {i}: {front}\")\n</code></pre>"},{"location":"api/#crowding_distanceobjectives","title":"crowding_distance(objectives)","text":"<p>Compute crowding distance.</p> <p>Parameters:</p> <ul> <li><code>objectives</code> (numpy.ndarray): Objective values with shape <code>(n_objectives, pop_size)</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>numpy.ndarray</code>: Array of crowding distances.</li> </ul> <p>Algorithm</p> <ul> <li>Sort individuals for each objective.</li> <li>Set boundary points\u2019 crowding distance to infinity.</li> <li>For interior points, sum the normalised differences of adjacent objective values.</li> <li>Return distances in the original order.</li> </ul> <p>Example:</p> <pre><code>from coords_nsga2.utils import crowding_distance\n\n# Compute crowding distance (pass a single front when needed)\ndistances = crowding_distance(values)\nprint(f\"Crowding distances: {distances}\")\n</code></pre>"},{"location":"api/#complete-example","title":"Complete Example","text":"<pre><code>import numpy as np\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\nfrom coords_nsga2.utils import fast_non_dominated_sort, crowding_distance\n\n# 1. Define the problem\ndef objective_1(coords):\n    \"\"\"Maximise the sum of x coordinates\"\"\"\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    \"\"\"Maximise the sum of y coordinates\"\"\"\n    return np.sum(coords[:, 1])\n\ndef constraint(coords):\n    \"\"\"Minimum spacing constraint\"\"\"\n    dist_list = distance.pdist(coords)\n    penalty = np.sum(0.1 - dist_list[dist_list &lt; 0.1])\n    return penalty\n\n# 2. Create region and problem\nregion = region_from_points([[0, 0], [1, 0], [1, 1], [0, 1]])\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=5,\n    region=region,\n    constraints=[constraint]\n)\n\n# 3. Create the optimiser\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# 4. Run optimisation\nresult = optimizer.run(100)\n\n# 5. Analyse results\nprint(f\"Final population shape: {result.shape}\")\nprint(f\"Objective 1 values: {optimizer.values_P[0]}\")\nprint(f\"Objective 2 values: {optimizer.values_P[1]}\")\n\n# 6. Find the Pareto front\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_front = result[fronts[0]]  # The first front is the Pareto front\nprint(f\"Number of Pareto-optimal solutions: {len(pareto_front)}\")\n</code></pre>"},{"location":"examples/","title":"Example Code","text":"<p>\u26a0\ufe0f Important Notice: This document is AI-generated based on source-code analysis. Although we strive for accuracy, inconsistencies or issues may still exist. We are actively improving and validating all content. If you encounter any problems, please report them promptly.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#1-simple-rectangular-region-optimization","title":"1. Simple Rectangular Region Optimization","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# Define a rectangular region\nregion = region_from_range(0, 10, 0, 5)\n\n# Define objective functions\ndef objective_1(coords):\n    \"\"\"Maximize the sum of x-coordinates\"\"\"\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    \"\"\"Maximize the sum of y-coordinates\"\"\"\n    return np.sum(coords[:, 1])\n\n# Create the problem (supports multiple objectives; two objectives here)\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=8,\n    region=region\n)\n\n# Create the optimizer\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# Run the optimization\nresult = optimizer.run(500)\n\n# Visualize the results\nplt.figure(figsize=(12, 5))\n\n# Plot the final population\nplt.subplot(1, 2, 1)\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Final Population')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.grid(True)\n\n# Plot objective-function values\nplt.subplot(1, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Objective Function Values')\nplt.xlabel('Objective 1')\nplt.ylabel('Objective 2')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/#2-polygonal-region-optimization-with-constraints","title":"2. Polygonal Region Optimization with Constraints","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# Define a polygonal region\nregion = region_from_points([\n    [0, 0],\n    [2, 0],\n    [3, 1],\n    [2, 2],\n    [0, 2],\n    [-1, 1]\n])\n\n# Define objective functions\ndef objective_1(coords):\n    \"\"\"Maximize the distance to the origin\"\"\"\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    return np.mean(distances)\n\ndef objective_2(coords):\n    \"\"\"Maximize the dispersion among points\"\"\"\n    return np.std(coords[:, 0]) + np.std(coords[:, 1])\n\n# Define constraints\ndef constraint_min_spacing(coords):\n    \"\"\"Minimum spacing constraint\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 0.5\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_max_spacing(coords):\n    \"\"\"Maximum spacing constraint\"\"\"\n    dist_list = distance.pdist(coords)\n    max_spacing = 3.0\n    violations = dist_list[dist_list &gt; max_spacing] - max_spacing\n    return np.sum(violations)\n\n# Create the problem\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=6,\n    region=region,\n    constraints=[constraint_min_spacing, constraint_max_spacing]\n)\n\n# Create the optimizer\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=30,\n    prob_crs=0.7,\n    prob_mut=0.05\n)\n\n# Run the optimization\nresult = optimizer.run(800)\n\n# Visualize the results\nplt.figure(figsize=(15, 5))\n\n# Plot the region and final population\nplt.subplot(1, 3, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='gray', ec='black', label='Region')\n\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Final Population in Region')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.legend()\nplt.grid(True)\n\n# Plot objective-function values\nplt.subplot(1, 3, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Objective Function Values')\nplt.xlabel('Objective 1 (Mean Distance)')\nplt.ylabel('Objective 2 (Spread)')\nplt.grid(True)\n\n# Plot optimization history\nplt.subplot(1, 3, 3)\nbest_obj1 = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_obj2 = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_obj1, label='Best Objective 1')\nplt.plot(best_obj2, label='Best Objective 2')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/#3-wind-turbine-layout-optimization","title":"3. Wind-Turbine Layout Optimization","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# Define the wind-farm area (irregular polygon)\nregion = region_from_points([\n    [0, 0],\n    [5, 0],\n    [8, 2],\n    [7, 5],\n    [4, 6],\n    [1, 4],\n    [-1, 2]\n])\n\n# Define objective functions\ndef objective_power_production(coords):\n    \"\"\"Maximize total power production (simplified model)\"\"\"\n    center = np.array([3.5, 3])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    power = np.sum(1 / (1 + distances))\n    return power\n\ndef objective_cost(coords):\n    \"\"\"Minimize total cost (simplified model)\"\"\"\n    total_distance = np.sum(np.sqrt(np.sum(coords**2, axis=1)))\n    return -total_distance  # Negative sign because we maximize\n\n# Define constraints\ndef constraint_turbine_spacing(coords):\n    \"\"\"Minimum spacing between turbines\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 2.0\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_boundary_distance(coords):\n    \"\"\"Minimum distance from the boundary\"\"\"\n    boundary_distance = 0.5\n    violations = 0\n    for point in coords:\n        x, y = point\n        if x &lt; boundary_distance or y &lt; boundary_distance:\n            violations += boundary_distance - min(x, y)\n        if x &gt; 8 - boundary_distance or y &gt; 6 - boundary_distance:\n            violations += max(0, x - (8 - boundary_distance)) + max(0, y - (6 - boundary_distance))\n    return violations\n\n# Create the problem\nproblem = Problem(\n    objectives=[objective_power_production, objective_cost],\n    n_points=12,  # 12 turbines\n    region=region,\n    constraints=[constraint_turbine_spacing, constraint_boundary_distance]\n)\n\n# Create the optimizer\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=50,\n    prob_crs=0.8,\n    prob_mut=0.02\n)\n\n# Run the optimization\nresult = optimizer.run(1000)\n\n# Visualize the results\nplt.figure(figsize=(15, 10))\n\n# Plot the wind-farm area and Pareto-optimal layouts\nplt.subplot(2, 2, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='lightblue', ec='blue', label='Wind Farm Area')\n\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_solutions = result[fronts[0]]\n\nfor i, solution in enumerate(pareto_solutions):\n    plt.scatter(solution[:, 0], solution[:, 1],\n                c=f'C{i}', marker='o', s=100, alpha=0.7,\n                label=f'Solution {i+1}')\n\nplt.title('Wind Turbine Layout \u2013 Pareto Optimal Solutions')\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.legend()\nplt.grid(True)\n\n# Plot objective-function space\nplt.subplot(2, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1], alpha=0.6, label='All Solutions')\nplt.scatter(optimizer.values_P[0][fronts[0]], optimizer.values_P[1][fronts[0]],\n            c='red', s=100, label='Pareto Front')\nplt.title('Objective Function Space')\nplt.xlabel('Power Production')\nplt.ylabel('Cost (negative)')\nplt.legend()\nplt.grid(True)\n\n# Plot optimization history\nplt.subplot(2, 2, 3)\nbest_power = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_cost = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_power, label='Best Power Production')\nplt.plot(best_cost, label='Best Cost')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\n# Plot convergence analysis\nplt.subplot(2, 2, 4)\navg_power = [np.mean(vals[0]) for vals in optimizer.values_history]\navg_cost = [np.mean(vals[1]) for vals in optimizer.values_history]\nplt.plot(avg_power, label='Average Power Production')\nplt.plot(avg_cost, label='Average Cost')\nplt.title('Population Average History')\nplt.xlabel('Generation')\nplt.ylabel('Average Objective Value')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# Output summary of best solutions\nprint(f\"Found {len(pareto_solutions)} Pareto-optimal solutions\")\nprint(f\"Best power production: {np.max(optimizer.values_P[0]):.4f}\")\nprint(f\"Best cost: {np.max(optimizer.values_P[1]):.4f}\")\n</code></pre>"},{"location":"examples/#4-sensor-network-deployment-optimization","title":"4. Sensor-Network Deployment Optimization","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# Define the monitoring area\nregion = region_from_range(0, 20, 0, 15)\n\n# Define objective functions\ndef objective_coverage(coords):\n    \"\"\"Maximize coverage area\"\"\"\n    coverage_radius = 3.0\n    x_grid, y_grid = np.meshgrid(np.linspace(0, 20, 50), np.linspace(0, 15, 40))\n    grid_points = np.column_stack([x_grid.ravel(), y_grid.ravel()])\n    covered_points = 0\n    for grid_point in grid_points:\n        distances = np.sqrt(np.sum((coords - grid_point)**2, axis=1))\n        if np.any(distances &lt;= coverage_radius):\n            covered_points += 1\n    return covered_points / len(grid_points)  # Coverage ratio\n\ndef objective_energy_efficiency(coords):\n    \"\"\"Maximize energy efficiency (minimize total transmission distance)\"\"\"\n    center = np.array([10, 7.5])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    total_distance = np.sum(distances)\n    return -total_distance  # Negative sign because we maximize\n\n# Define constraints\ndef constraint_sensor_spacing(coords):\n    \"\"\"Minimum spacing between sensors\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 2.0\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_battery_life(coords):\n    \"\"\"Battery-life constraint (based on distance to the center node)\"\"\"\n    center = np.array([10, 7.5])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    max_distance = 12.0\n    violations = distances[distances &gt; max_distance] - max_distance\n    return np.sum(violations)\n\n# Create the problem\nproblem = Problem(\n    objectives=[objective_coverage, objective_energy_efficiency],\n    n_points=8,  # 8 sensors\n    region=region,\n    constraints=[constraint_sensor_spacing, constraint_battery_life]\n)\n\n# Create the optimizer\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=40,\n    prob_crs=0.6,\n    prob_mut=0.03\n)\n\n# Run the optimization\nresult = optimizer.run(600)\n\n# Visualize the results\nplt.figure(figsize=(16, 12))\n\n# Plot monitoring area and sensor deployment\nplt.subplot(2, 3, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.1, fc='lightgreen', ec='green', label='Monitoring Area')\n\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_solutions = result[fronts[0]]\n\n# Plot the first Pareto-optimal solution\nbest_solution = pareto_solutions[0]\nplt.scatter(best_solution[:, 0], best_solution[:, 1],\n            c='red', marker='s', s=200, label='Sensors')\n\ncoverage_radius = 3.0\nfor sensor in best_solution:\n    circle = plt.Circle(sensor, coverage_radius, alpha=0.2, fc='blue')\n    plt.gca().add_patch(circle)\n\nplt.scatter(10, 7.5, c='black', marker='*', s=300, label='Center Node')\nplt.title('Sensor Network Deployment')\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.legend()\nplt.grid(True)\n\n# Plot objective-function space\nplt.subplot(2, 3, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1], alpha=0.6, label='All Solutions')\nplt.scatter(optimizer.values_P[0][fronts[0]], optimizer.values_P[1][fronts[0]],\n            c='red', s=100, label='Pareto Front')\nplt.title('Objective Function Space')\nplt.xlabel('Coverage Rate')\nplt.ylabel('Energy Efficiency')\nplt.legend()\nplt.grid(True)\n\n# Plot optimization history\nplt.subplot(2, 3, 3)\nbest_coverage = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_energy = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_coverage, label='Best Coverage')\nplt.plot(best_energy, label='Best Energy Efficiency')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\n# Plot population diversity\nplt.subplot(2, 3, 4)\ndiversity_coverage = [np.std(vals[0]) for vals in optimizer.values_history]\ndiversity_energy = [np.std(vals[1]) for vals in optimizer.values_history]\nplt.plot(diversity_coverage, label='Coverage Diversity')\nplt.plot(diversity_energy, label='Energy Diversity')\nplt.title('Population Diversity')\nplt.xlabel('Generation')\nplt.ylabel('Standard Deviation')\nplt.legend()\nplt.grid(True)\n\n# Plot population averages\nplt.subplot(2, 3, 5)\navg_coverage = [np.mean(vals[0]) for vals in optimizer.values_history]\navg_energy = [np.mean(vals[1]) for vals in optimizer.values_history]\nplt.plot(avg_coverage, label='Average Coverage')\nplt.plot(avg_energy, label='Average Energy Efficiency')\nplt.title('Population Average')\nplt.xlabel('Generation')\nplt.ylabel('Average Objective Value')\nplt.legend()\nplt.grid(True)\n\n# Plot Pareto front\nplt.subplot(2, 3, 6)\npareto_coverage = optimizer.values_P[0][fronts[0]]\npareto_energy = optimizer.values_P[1][fronts[0]]\nplt.scatter(pareto_coverage, pareto_energy, c='red', s=100)\nplt.title('Pareto Front')\nplt.xlabel('Coverage Rate')\nplt.ylabel('Energy Efficiency')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# Output summary\nprint(\"Sensor-network deployment optimization completed\")\nprint(f\"Found {len(pareto_solutions)} Pareto-optimal solutions\")\nprint(f\"Best coverage: {np.max(optimizer.values_P[0]):.4f}\")\nprint(f\"Best energy efficiency: {np.max(optimizer.values_P[1]):.4f}\")\n</code></pre>"},{"location":"examples/#custom-operator-example","title":"Custom Operator Example","text":""},{"location":"examples/#5-custom-crossover-and-mutation-operators","title":"5. Custom Crossover and Mutation Operators","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# Define a custom crossover operator\ndef custom_crossover(population, prob_crs):\n    \"\"\"Distance-based crossover\"\"\"\n    n_points = population.shape[1]\n    for i in range(0, len(population), 2):\n        if np.random.rand() &lt; prob_crs:\n            parent1 = population[i]\n            parent2 = population[i+1]\n            distances = np.sqrt(np.sum((parent1 - parent2)**2, axis=1))\n            cross_points = distances &gt; np.median(distances)\n            population[i, cross_points] = parent2[cross_points]\n            population[i+1, cross_points] = parent1[cross_points]\n    return population\n\n# Define a custom mutation operator\ndef custom_mutation(population, prob_mut, region):\n    \"\"\"Gaussian mutation with region check\"\"\"\n    from coords_nsga2.spatial import create_points_in_polygon\n    mutation_mask = np.random.random(population.shape[:-1]) &lt; prob_mut\n    for i in range(len(population)):\n        for j in range(population.shape[1]):\n            if mutation_mask[i, j]:\n                current_point = population[i, j]\n                new_point = current_point + np.random.normal(0, 0.5, 2)\n                if region.contains(plt.matplotlib.patches.Circle(new_point, 0)):\n                    population[i, j] = new_point\n                else:\n                    population[i, j] = create_points_in_polygon(region, 1)[0]\n    return population\n\n# Define region and objective functions\nregion = region_from_range(0, 10, 0, 10)\n\ndef objective_1(coords):\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    return np.sum(coords[:, 1])\n\n# Create the problem\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=5,\n    region=region\n)\n\n# Create the optimizer and replace operators\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\noptimizer.crossover = custom_crossover\noptimizer.mutation = custom_mutation\n\n# Run the optimization\nresult = optimizer.run(300)\n\n# Visualize the results\nplt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='gray', ec='black')\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Custom Operators \u2013 Final Population')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.grid(True)\n\nplt.subplot(1, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Custom Operators \u2013 Objective Values')\nplt.xlabel('Objective 1')\nplt.ylabel('Objective 2')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>These examples showcase various ways to use the Coords-NSGA2 library, ranging from basic multi-objective optimization to complex real-world applications. Feel free to modify them to suit your needs.</p>"},{"location":"","title":"Home","text":""},{"location":"#welcome-to-coords-nsga2","title":"Welcome to Coords-NSGA2","text":"<p>\u26a0\ufe0f Important Notice: This document is AI-generated based on source-code analysis. Although we strive for accuracy, inconsistencies or issues may still exist. We are actively improving and validating all content. If you encounter any problems, please report them promptly.</p> <p>Coords-NSGA2 is a Python library for multi-objective optimization of coordinate layouts, built upon an enhanced version of the NSGA-II algorithm.</p>"},{"location":"#overview","title":"Overview","text":"<p>Coords-NSGA2 is a Python library specifically designed for optimizing the layout of coordinate points, based on an improved implementation of the classic NSGA-II (Non-Dominated Sorting Genetic Algorithm II).</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Coordinate-focused optimization: Purpose-built for optimizing point layouts  </li> <li>Specialized constraints: Built-in support for inter-point spacing, boundary limits, and custom constraints  </li> <li>Customized genetic operators: Crossover and mutation operators tailored to coordinate data  </li> <li>Multi-objective optimization: Leveraging the proven NSGA-II algorithm  </li> <li>Flexible region definitions: Supports both polygonal and rectangular regions  </li> <li>Lightweight and extensible: Easy to add custom operators and constraints  </li> <li>Progress tracking: Built-in progress bar and optimization history  </li> <li>Save/Load capability: Persist and restore optimization state  </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ul> <li>Installation: See the Installation Guide </li> <li>Usage: Detailed tutorial in the User Guide </li> <li>API Reference: Refer to the API Documentation </li> <li>Examples: Browse the Example Code </li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Wind turbine layout optimization  </li> <li>Sensor network deployment  </li> <li>Facility location problems  </li> <li>Robot path planning  </li> <li>Any scenario requiring optimized coordinate layouts  </li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.9+</li> <li>NumPy &gt;= 1.23</li> <li>tqdm &gt;= 4</li> <li>Shapely &gt;= 2</li> <li>SciPy (optional, for distance computations)</li> <li>matplotlib (optional, for result visualization)</li> </ul>"},{"location":"install/","title":"Installation Guide","text":"<p>\u26a0\ufe0f Important Notice: This document is AI-generated based on source-code analysis. Although we strive for accuracy, inconsistencies or issues may still exist. We are actively improving and validating all content. If you encounter any problems, please report them promptly.</p>"},{"location":"install/#installation-chinese","title":"Installation (Chinese)","text":""},{"location":"install/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>pip package manager</li> </ul>"},{"location":"install/#install-from-pypi-recommended","title":"Install from PyPI (Recommended)","text":"<pre><code>pip install coords-nsga2\n</code></pre>"},{"location":"install/#install-from-source","title":"Install from Source","text":"<p>If you want the latest development version or plan to modify the code:</p> <pre><code>git clone https://github.com/ZXF1001/coords-nsga2.git\ncd coords-nsga2\npip install -e .\n</code></pre>"},{"location":"install/#set-up-a-development-environment","title":"Set Up a Development Environment","text":"<p>If you intend to contribute:</p> <pre><code>git clone https://github.com/ZXF1001/coords-nsga2.git\ncd coords-nsga2\npip install -e \".[test]\"\n</code></pre>"},{"location":"install/#verify-the-installation","title":"Verify the Installation","text":"<p>After installation, verify with:</p> <pre><code>import coords_nsga2\nprint(coords_nsga2.__version__)\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":""},{"location":"install/#required","title":"Required","text":"<ul> <li>numpy &gt;= 1.23: Numerical computation</li> <li>tqdm &gt;= 4: Progress bars</li> <li>shapely &gt;= 2: Geometry operations</li> </ul>"},{"location":"install/#optional","title":"Optional","text":"<ul> <li>scipy: Distance calculations and other scientific computing</li> <li>matplotlib: Result visualization</li> </ul>"},{"location":"install/#development","title":"Development","text":"<ul> <li>pytest &gt;= 8.2: Testing framework</li> <li>pytest-cov &gt;= 5: Test coverage</li> <li>coverage[toml] &gt;= 7.5: Code coverage</li> <li>hypothesis &gt;= 6.100: Property-based testing</li> <li>ruff &gt;= 0.11: Code formatting and linting</li> <li>pre-commit &gt;= 3.7: Git hooks</li> </ul>"},{"location":"usage/","title":"Usage Guide","text":"<p>\u26a0\ufe0f Important Notice: This document is AI-generated based on source-code analysis. Although we strive for accuracy, inconsistencies or issues may still exist. We are actively improving and validating all content. If you encounter any problems, please report them promptly.</p>"},{"location":"usage/#english-usage-guide","title":"English Usage Guide","text":""},{"location":"usage/#basic-concepts","title":"Basic Concepts","text":"<p>The core concepts of Coords-NSGA2 library include:</p> <ol> <li>Problem: Defines the optimization problem's objective functions, constraints, and search region</li> <li>CoordsNSGA2: The optimizer that executes the NSGA-II algorithm</li> <li>Region: Defines the valid search space for coordinate points</li> <li>Constraints: Conditions that limit the feasibility of solutions</li> </ol>"},{"location":"usage/#quick-start-example","title":"Quick Start Example","text":"<p>Here's a complete usage example demonstrating how to optimize the layout of 10 coordinate points:</p> <pre><code>import numpy as np\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# 1. Define optimization region (polygon)\nregion = region_from_points([\n    [0, 0],\n    [1, 0],\n    [2, 1],\n    [1, 1],\n])\n\n# 2. Define objective functions\ndef objective_1(coords):\n    \"\"\"First objective: maximize coordinate sum\"\"\"\n    return np.sum(coords[:, 0]) + np.sum(coords[:, 1])\n\ndef objective_2(coords):\n    \"\"\"Second objective: maximize point spread\"\"\"\n    return np.std(coords[:, 0]) + np.std(coords[:, 1])\n\n# 3. Define constraints\nspacing = 0.05  # minimum spacing\ndef constraint_1(coords):\n    \"\"\"Constraint: minimum spacing between points\"\"\"\n    dist_list = distance.pdist(coords)\n    penalty_list = spacing - dist_list[dist_list &lt; spacing]\n    return np.sum(penalty_list)\n\n# 4. Create problem instance (supports arbitrary number of objectives)\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=10,\n    region=region,\n    constraints=[constraint_1]\n)\n\n# 5. Create optimizer\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# 6. Run optimization\nresult = optimizer.run(1000)\n\n# 7. View results\nprint(f\"Optimization complete! Result shape: {result.shape}\")\nprint(f\"Population size: {len(result)}\")\nprint(f\"Points per solution: {result.shape[1]}\")\n</code></pre>"},{"location":"usage/#region-definition","title":"Region Definition","text":""},{"location":"usage/#create-polygon-region-from-point-list","title":"Create polygon region from point list","text":"<pre><code>from coords_nsga2.spatial import region_from_points\n\n# Define polygon vertices\npoints = [\n    [0, 0],\n    [1, 0],\n    [2, 1],\n    [1, 1],\n]\nregion = region_from_points(points)\n</code></pre>"},{"location":"usage/#create-rectangular-region-from-coordinate-bounds","title":"Create rectangular region from coordinate bounds","text":"<pre><code>from coords_nsga2.spatial import region_from_range\n\n# Define rectangle bounds\nregion = region_from_range(x_min=0, x_max=10, y_min=0, y_max=5)\n</code></pre>"},{"location":"usage/#objective-function-definition","title":"Objective Function Definition","text":"<p>Objective functions should accept a numpy array of shape <code>(n_points, 2)</code> as input and return a scalar value:</p> <pre><code>def my_objective(coords):\n    \"\"\"\n    Parameters:\n        coords: numpy array of shape (n_points, 2)\n                each row is a coordinate point [x, y]\n\n    Returns:\n        float: objective function value\n    \"\"\"\n    # Example: calculate average distance to origin\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    return np.mean(distances)\n</code></pre>"},{"location":"usage/#constraint-definition","title":"Constraint Definition","text":"<p>Constraint functions should return penalty values for constraint violations. Return 0 if no constraints are violated:</p> <pre><code>def my_constraint(coords):\n    \"\"\"\n    Parameters:\n        coords: numpy array of shape (n_points, 2)\n\n    Returns:\n        float: penalty value for constraint violation (0 means no violation)\n    \"\"\"\n    # Example: ensure all points are within unit circle\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    violations = distances[distances &gt; 1] - 1\n    return np.sum(violations)\n</code></pre>"},{"location":"usage/#optimizer-parameters","title":"Optimizer Parameters","text":""},{"location":"usage/#coordsnsga2-parameter-description","title":"CoordsNSGA2 Parameter Description","text":"<ul> <li><code>problem</code>: Problem instance</li> <li><code>pop_size</code>: Population size (must be even)</li> <li><code>prob_crs</code>: Crossover probability (between 0-1)</li> <li><code>prob_mut</code>: Mutation probability (between 0-1)</li> <li><code>random_seed</code>: Random seed (for reproducibility)</li> </ul>"},{"location":"usage/#parameter-tuning-suggestions","title":"Parameter Tuning Suggestions","text":"<ul> <li>Population size: Usually set to 20-100, use larger populations for complex problems</li> <li>Crossover probability: Usually set to 0.5-0.9</li> <li>Mutation probability: Usually set to 0.01-0.1</li> <li>Generations: Set based on problem complexity, usually 100-1000 generations</li> </ul>"},{"location":"usage/#result-analysis","title":"Result Analysis","text":"<p>After optimization is complete, you can access the following attributes:</p> <pre><code># Final population\nfinal_population = optimizer.P\n\n# Objective function values (shape: n_objectives \u00d7 pop_size)\nvalues = optimizer.values_P\nvalues1 = values[0]\nvalues2 = values[1]\n\n# Optimization history\npopulation_history = optimizer.P_history\nvalues_history = optimizer.values_history  # list of (n_objectives, pop_size) per generation\n\n# Find Pareto optimal solutions (based on last generation objective values)\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_front = optimizer.P[fronts[0]]\n</code></pre>"},{"location":"usage/#save-and-load","title":"Save and Load","text":"<pre><code># Save optimization state\noptimizer.save(\"optimization_result.npz\")\n\n# Load optimization state\noptimizer.load(\"optimization_result.npz\")\n</code></pre>"},{"location":"zh/api/","title":"API \u53c2\u8003\u6587\u6863","text":"<p>\u26a0\ufe0f \u91cd\u8981\u63d0\u793a: \u672c\u6587\u6863\u662f\u57fa\u4e8e\u6e90\u7801\u5206\u6790\u7531AI\u751f\u6210\u7684\u3002\u867d\u7136\u6211\u4eec\u52aa\u529b\u786e\u4fdd\u51c6\u786e\u6027\uff0c\u4f46\u4ecd\u53ef\u80fd\u5b58\u5728\u4e0d\u4e00\u81f4\u6216\u95ee\u9898\u3002\u6211\u4eec\u6b63\u5728\u79ef\u6781\u6539\u8fdb\u548c\u9a8c\u8bc1\u6240\u6709\u5185\u5bb9\u3002\u5982\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u53ca\u65f6\u62a5\u544a\u3002</p>"},{"location":"zh/api/#_1","title":"\u6838\u5fc3\u7c7b","text":""},{"location":"zh/api/#problem","title":"Problem","text":"<p>\u591a\u76ee\u6807\u4f18\u5316\u95ee\u9898\u5b9a\u4e49\u7c7b\u3002</p> <p>\u6784\u9020\u51fd\u6570\uff1a</p> <pre><code>Problem(objectives, n_points, region, constraints=[], penalty_weight=1e6)\n</code></pre> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>objectives</code> (list[callable]): \u76ee\u6807\u51fd\u6570\u5217\u8868\uff0c\u6bcf\u4e2a\u51fd\u6570\u63a5\u53d7 <code>coords (n_points, 2)</code> \u5e76\u8fd4\u56de\u6807\u91cf</li> <li><code>n_points</code> (int): \u8981\u4f18\u5316\u7684\u5750\u6807\u70b9\u6570\u91cf</li> <li><code>region</code> (shapely.geometry.Polygon): \u5b9a\u4e49\u6709\u6548\u533a\u57df\u7684Shapely\u591a\u8fb9\u5f62</li> <li><code>constraints</code> (list, optional): \u7ea6\u675f\u51fd\u6570\u5217\u8868\uff0c\u9ed8\u8ba4\u4e3a\u7a7a\u5217\u8868</li> <li><code>penalty_weight</code> (float, optional): \u7ea6\u675f\u8fdd\u53cd\u7684\u6743\u91cd\uff0c\u9ed8\u8ba4\u4e3a1e6</li> </ul> <p>\u65b9\u6cd5\uff1a</p>"},{"location":"zh/api/#sample_populationpop_size","title":"sample_population(pop_size)","text":"<p>\u751f\u6210\u521d\u59cb\u79cd\u7fa4\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>pop_size</code> (int): \u79cd\u7fa4\u5927\u5c0f</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u5f62\u72b6\u4e3a(pop_size, n_points, 2)\u7684\u79cd\u7fa4\u6570\u7ec4</li> </ul>"},{"location":"zh/api/#evaluatepopulation","title":"evaluate(population)","text":"<p>\u8bc4\u4f30\u79cd\u7fa4\u4e2d\u6240\u6709\u4e2a\u4f53\u7684\u76ee\u6807\u51fd\u6570\u503c\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>population</code> (numpy.ndarray): \u5f62\u72b6\u4e3a(pop_size, n_points, 2)\u7684\u79cd\u7fa4</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u5f62\u72b6\u4e3a <code>(n_objectives, pop_size)</code> \u7684\u76ee\u6807\u51fd\u6570\u503c\u6570\u7ec4</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2 import Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef obj1(coords):\n    return np.sum(coords[:, 0])\n\ndef obj2(coords):\n    return np.sum(coords[:, 1])\n\n# \u521b\u5efa\u95ee\u9898\nregion = region_from_points([[0,0], [1,0], [1,1], [0,1]])\nproblem = Problem(objectives=[obj1, obj2], n_points=5, region=region)\n\n# \u751f\u6210\u521d\u59cb\u79cd\u7fa4\npopulation = problem.sample_population(10)\nprint(f\"\u79cd\u7fa4\u5f62\u72b6: {population.shape}\")  # (10, 5, 2)\n\n# \u8bc4\u4f30\u79cd\u7fa4\nvalues = problem.evaluate(population)  # shape: (n_objectives, pop_size)\nprint(f\"\u76ee\u6807\u51fd\u65701\u503c: {values[0]}\")\nprint(f\"\u76ee\u6807\u51fd\u65702\u503c: {values[1]}\")\n</code></pre>"},{"location":"zh/api/#coordsnsga2","title":"CoordsNSGA2","text":"<p>NSGA-II\u5750\u6807\u4f18\u5316\u5668\u7c7b\u3002</p> <p>\u6784\u9020\u51fd\u6570\uff1a</p> <pre><code>CoordsNSGA2(problem, pop_size, prob_crs, prob_mut, random_seed=42)\n</code></pre> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>problem</code> (Problem): \u95ee\u9898\u5b9e\u4f8b</li> <li><code>pop_size</code> (int): \u79cd\u7fa4\u5927\u5c0f\uff08\u5fc5\u987b\u4e3a\u5076\u6570\uff09</li> <li><code>prob_crs</code> (float): \u4ea4\u53c9\u6982\u7387\uff080-1\u4e4b\u95f4\uff09</li> <li><code>prob_mut</code> (float): \u53d8\u5f02\u6982\u7387\uff080-1\u4e4b\u95f4\uff09</li> <li><code>random_seed</code> (int, optional): \u968f\u673a\u79cd\u5b50\uff0c\u9ed8\u8ba4\u4e3a42</li> </ul> <p>\u5c5e\u6027\uff1a</p> <ul> <li><code>P</code>: \u5f53\u524d\u79cd\u7fa4\uff0c\u5f62\u72b6 <code>(pop_size, n_points, 2)</code></li> <li><code>values_P</code>: \u5f53\u524d\u79cd\u7fa4\u7684\u76ee\u6807\u51fd\u6570\u503c\uff0c\u5f62\u72b6 <code>(n_objectives, pop_size)</code></li> <li><code>P_history</code>: \u79cd\u7fa4\u5386\u53f2\u8bb0\u5f55</li> <li><code>values_history</code>: \u5386\u53f2\u76ee\u6807\u51fd\u6570\u503c\u5217\u8868\uff0c\u6bcf\u4ee3\u4e00\u4e2a <code>(n_objectives, pop_size)</code> \u6570\u7ec4</li> </ul> <p>\u65b9\u6cd5\uff1a</p>"},{"location":"zh/api/#rungenerations-verbosetrue","title":"run(generations, verbose=True)","text":"<p>\u8fd0\u884c\u4f18\u5316\u7b97\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>generations</code> (int): \u4f18\u5316\u4ee3\u6570</li> <li><code>verbose</code> (bool, optional): \u662f\u5426\u663e\u793a\u8fdb\u5ea6\u6761\uff0c\u9ed8\u8ba4\u4e3aTrue</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u6700\u7ec8\u79cd\u7fa4</li> </ul>"},{"location":"zh/api/#savepath","title":"save(path)","text":"<p>\u4fdd\u5b58\u4f18\u5316\u72b6\u6001\u5230\u6587\u4ef6\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>path</code> (str): \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84</li> </ul>"},{"location":"zh/api/#loadpath","title":"load(path)","text":"<p>\u4ece\u6587\u4ef6\u52a0\u8f7d\u4f18\u5316\u72b6\u6001\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>path</code> (str): \u52a0\u8f7d\u6587\u4ef6\u8def\u5f84</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2 import CoordsNSGA2, Problem\n\n# \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(1000)\n\n# \u4fdd\u5b58\u7ed3\u679c\noptimizer.save(\"optimization_result.npz\")\n\n# \u52a0\u8f7d\u7ed3\u679c\noptimizer.load(\"optimization_result.npz\")\n</code></pre>"},{"location":"zh/api/#_2","title":"\u7a7a\u95f4\u5de5\u5177","text":""},{"location":"zh/api/#region_from_pointspoints","title":"region_from_points(points)","text":"<p>\u4ece\u5750\u6807\u70b9\u5217\u8868\u521b\u5efa\u591a\u8fb9\u5f62\u533a\u57df\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>points</code> (list): \u5750\u6807\u70b9\u5217\u8868\uff0c\u683c\u5f0f\u4e3a[[x1,y1], [x2,y2], ...]</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>shapely.geometry.Polygon</code>: Shapely\u591a\u8fb9\u5f62\u5bf9\u8c61</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.spatial import region_from_points\n\n# \u521b\u5efa\u4e09\u89d2\u5f62\u533a\u57df\npoints = [[0, 0], [1, 0], [0.5, 1]]\nregion = region_from_points(points)\nprint(f\"\u533a\u57df\u9762\u79ef: {region.area}\")\n</code></pre>"},{"location":"zh/api/#region_from_rangex_min-x_max-y_min-y_max","title":"region_from_range(x_min, x_max, y_min, y_max)","text":"<p>\u4ece\u5750\u6807\u8fb9\u754c\u521b\u5efa\u77e9\u5f62\u533a\u57df\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>x_min</code> (float): x\u5750\u6807\u6700\u5c0f\u503c</li> <li><code>x_max</code> (float): x\u5750\u6807\u6700\u5927\u503c</li> <li><code>y_min</code> (float): y\u5750\u6807\u6700\u5c0f\u503c</li> <li><code>y_max</code> (float): y\u5750\u6807\u6700\u5927\u503c</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>shapely.geometry.Polygon</code>: Shapely\u77e9\u5f62\u5bf9\u8c61</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.spatial import region_from_range\n\n# \u521b\u5efa\u77e9\u5f62\u533a\u57df\nregion = region_from_range(0, 10, 0, 5)\nprint(f\"\u533a\u57df\u8fb9\u754c: {region.bounds}\")\n</code></pre>"},{"location":"zh/api/#create_points_in_polygonpolygon-n","title":"create_points_in_polygon(polygon, n)","text":"<p>\u5728\u591a\u8fb9\u5f62\u5185\u751f\u6210n\u4e2a\u968f\u673a\u70b9\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>polygon</code> (shapely.geometry.Polygon): \u76ee\u6807\u591a\u8fb9\u5f62</li> <li><code>n</code> (int): \u8981\u751f\u6210\u7684\u70b9\u6570\u91cf</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u5f62\u72b6\u4e3a(n, 2)\u7684\u5750\u6807\u70b9\u6570\u7ec4</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.spatial import create_points_in_polygon, region_from_points\n\n# \u521b\u5efa\u533a\u57df\nregion = region_from_points([[0,0], [1,0], [1,1], [0,1]])\n\n# \u751f\u6210\u968f\u673a\u70b9\npoints = create_points_in_polygon(region, 10)\nprint(f\"\u751f\u6210\u7684\u70b9: {points}\")\n</code></pre>"},{"location":"zh/api/#_3","title":"\u9057\u4f20\u7b97\u5b50","text":""},{"location":"zh/api/#coords_crossoverpopulation-prob_crs","title":"coords_crossover(population, prob_crs)","text":"<p>\u5750\u6807\u7279\u5b9a\u7684\u4ea4\u53c9\u7b97\u5b50\uff0c\u5728\u7236\u4ee3\u4e4b\u95f4\u4ea4\u6362\u70b9\u5b50\u96c6\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>population</code> (numpy.ndarray): \u5f62\u72b6\u4e3a(pop_size, n_points, 2)\u7684\u79cd\u7fa4</li> <li><code>prob_crs</code> (float): \u4ea4\u53c9\u6982\u7387</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u4ea4\u53c9\u540e\u7684\u79cd\u7fa4</li> </ul> <p>\u7b97\u6cd5\u8bf4\u660e\uff1a</p> <ul> <li>\u5bf9\u6bcf\u5bf9\u7236\u4ee3\u4e2a\u4f53\uff0c\u4ee5\u6982\u7387prob_crs\u8fdb\u884c\u4ea4\u53c9</li> <li>\u968f\u673a\u9009\u62e91\u5230n_points-1\u4e2a\u70b9\u8fdb\u884c\u4ea4\u6362</li> <li>\u4fdd\u6301\u79cd\u7fa4\u5927\u5c0f\u4e0d\u53d8</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.operators.crossover import coords_crossover\n\n# \u6267\u884c\u4ea4\u53c9\u64cd\u4f5c\nnew_population = coords_crossover(population, prob_crs=0.5)\n</code></pre>"},{"location":"zh/api/#coords_mutationpopulation-prob_mut-region","title":"coords_mutation(population, prob_mut, region)","text":"<p>\u5750\u6807\u7279\u5b9a\u7684\u53d8\u5f02\u7b97\u5b50\uff0c\u5728\u533a\u57df\u5185\u968f\u673a\u91cd\u65b0\u5b9a\u4f4d\u70b9\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>population</code> (numpy.ndarray): \u5f62\u72b6\u4e3a(pop_size, n_points, 2)\u7684\u79cd\u7fa4</li> <li><code>prob_mut</code> (float): \u53d8\u5f02\u6982\u7387</li> <li><code>region</code> (shapely.geometry.Polygon): \u6709\u6548\u533a\u57df</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u53d8\u5f02\u540e\u7684\u79cd\u7fa4</li> </ul> <p>\u7b97\u6cd5\u8bf4\u660e\uff1a</p> <ul> <li>\u5bf9\u6bcf\u4e2a\u5750\u6807\u70b9\uff0c\u4ee5\u6982\u7387prob_mut\u8fdb\u884c\u53d8\u5f02</li> <li>\u53d8\u5f02\u65f6\u5728\u533a\u57df\u5185\u91cd\u65b0\u751f\u6210\u968f\u673a\u4f4d\u7f6e</li> <li>\u786e\u4fdd\u53d8\u5f02\u540e\u7684\u70b9\u4ecd\u5728\u6709\u6548\u533a\u57df\u5185</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.operators.mutation import coords_mutation\n\n# \u6267\u884c\u53d8\u5f02\u64cd\u4f5c\nnew_population = coords_mutation(population, prob_mut=0.1, region=region)\n</code></pre>"},{"location":"zh/api/#coords_selectionpopulation-values_p-tourn_size3","title":"coords_selection(population, values_P, tourn_size=3)","text":"<p>\u57fa\u4e8e\u975e\u652f\u914d\u6392\u5e8f\u548c\u62e5\u6324\u8ddd\u79bb\u7684\u9526\u6807\u8d5b\u9009\u62e9\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>population</code> (numpy.ndarray): \u5f62\u72b6\u4e3a <code>(pop_size, n_points, 2)</code> \u7684\u79cd\u7fa4</li> <li><code>values_P</code> (numpy.ndarray): \u5f62\u72b6\u4e3a <code>(n_objectives, pop_size)</code> \u7684\u76ee\u6807\u51fd\u6570\u503c\u6570\u7ec4</li> <li><code>tourn_size</code> (int, optional): \u9526\u6807\u8d5b\u5927\u5c0f\uff0c\u9ed8\u8ba4\u4e3a3</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u9009\u62e9\u540e\u7684\u79cd\u7fa4</li> </ul> <p>\u7b97\u6cd5\u8bf4\u660e\uff1a</p> <ul> <li>\u4f7f\u7528\u5feb\u901f\u975e\u652f\u914d\u6392\u5e8f\u786e\u5b9a\u524d\u6cbf\u7b49\u7ea7</li> <li>\u8ba1\u7b97\u6bcf\u4e2a\u524d\u6cbf\u5185\u7684\u62e5\u6324\u8ddd\u79bb</li> <li>\u4f7f\u7528\u9526\u6807\u8d5b\u9009\u62e9\uff0c\u4f18\u5148\u9009\u62e9\u524d\u6cbf\u7b49\u7ea7\u4f4e\u7684\u4e2a\u4f53</li> <li>\u524d\u6cbf\u7b49\u7ea7\u76f8\u540c\u65f6\uff0c\u9009\u62e9\u62e5\u6324\u8ddd\u79bb\u5927\u7684\u4e2a\u4f53</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.operators.selection import coords_selection\n\n# \u6267\u884c\u9009\u62e9\u64cd\u4f5c\nselected_population = coords_selection(population, values_P, tourn_size=3)\n</code></pre>"},{"location":"zh/api/#_4","title":"\u5de5\u5177\u51fd\u6570","text":""},{"location":"zh/api/#fast_non_dominated_sortobjectives","title":"fast_non_dominated_sort(objectives)","text":"<p>\u5feb\u901f\u975e\u652f\u914d\u6392\u5e8f\u7b97\u6cd5\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>objectives</code> (numpy.ndarray): \u5f62\u72b6\u4e3a <code>(n_objectives, pop_size)</code> \u7684\u76ee\u6807\u51fd\u6570\u503c\u6570\u7ec4</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>list</code>: \u524d\u6cbf\u5217\u8868\uff0c\u6bcf\u4e2a\u524d\u6cbf\u5305\u542b\u8be5\u524d\u6cbf\u4e2d\u4e2a\u4f53\u7684\u7d22\u5f15</li> </ul> <p>\u7b97\u6cd5\u8bf4\u660e\uff1a</p> <ul> <li>\u8ba1\u7b97\u6bcf\u4e2a\u4e2a\u4f53\u88ab\u652f\u914d\u7684\u6b21\u6570</li> <li>\u8bb0\u5f55\u6bcf\u4e2a\u4e2a\u4f53\u652f\u914d\u7684\u5176\u4ed6\u4e2a\u4f53</li> <li>\u6309\u524d\u6cbf\u7b49\u7ea7\u5bf9\u4e2a\u4f53\u8fdb\u884c\u6392\u5e8f</li> <li>\u8fd4\u56de\u6309\u524d\u6cbf\u5206\u7ec4\u7684\u4e2a\u4f53\u7d22\u5f15</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.utils import fast_non_dominated_sort\n\n# \u6267\u884c\u975e\u652f\u914d\u6392\u5e8f\nfronts = fast_non_dominated_sort(values)\nprint(f\"\u524d\u6cbf\u6570\u91cf: {len(fronts)}\")\nfor i, front in enumerate(fronts):\n    print(f\"\u524d\u6cbf{i}: {front}\")\n</code></pre>"},{"location":"zh/api/#crowding_distanceobjectives","title":"crowding_distance(objectives)","text":"<p>\u8ba1\u7b97\u62e5\u6324\u8ddd\u79bb\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>objectives</code> (numpy.ndarray): \u5f62\u72b6\u4e3a <code>(n_objectives, pop_size)</code> \u7684\u76ee\u6807\u51fd\u6570\u503c\u6570\u7ec4</li> </ul> <p>\u8fd4\u56de\uff1a</p> <ul> <li><code>numpy.ndarray</code>: \u62e5\u6324\u8ddd\u79bb\u6570\u7ec4</li> </ul> <p>\u7b97\u6cd5\u8bf4\u660e\uff1a</p> <ul> <li>\u5bf9\u6bcf\u4e2a\u76ee\u6807\u51fd\u6570\u503c\u8fdb\u884c\u6392\u5e8f</li> <li>\u8fb9\u754c\u70b9\u7684\u62e5\u6324\u8ddd\u79bb\u8bbe\u4e3a\u65e0\u7a77\u5927</li> <li>\u4e2d\u95f4\u70b9\u7684\u62e5\u6324\u8ddd\u79bb\u4e3a\u76f8\u90bb\u70b9\u76ee\u6807\u51fd\u6570\u503c\u5dee\u7684\u5f52\u4e00\u5316\u548c</li> <li>\u8fd4\u56de\u6309\u539f\u59cb\u987a\u5e8f\u6392\u5217\u7684\u62e5\u6324\u8ddd\u79bb</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>from coords_nsga2.utils import crowding_distance\n\n# \u8ba1\u7b97\u62e5\u6324\u8ddd\u79bb\uff08\u5bf9\u540c\u4e00\u524d\u6cbf\u5b50\u96c6\u8ba1\u7b97\u65f6\u4f20\u5165\u5b50\u96c6\uff09\ndistances = crowding_distance(values)\nprint(f\"\u62e5\u6324\u8ddd\u79bb: {distances}\")\n</code></pre>"},{"location":"zh/api/#_5","title":"\u5b8c\u6574\u793a\u4f8b","text":"<pre><code>import numpy as np\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\nfrom coords_nsga2.utils import fast_non_dominated_sort, crowding_distance\n\n# 1. \u5b9a\u4e49\u95ee\u9898\ndef objective_1(coords):\n    \"\"\"\u6700\u5927\u5316x\u5750\u6807\u548c\"\"\"\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    \"\"\"\u6700\u5927\u5316y\u5750\u6807\u548c\"\"\"\n    return np.sum(coords[:, 1])\n\ndef constraint(coords):\n    \"\"\"\u6700\u5c0f\u95f4\u8ddd\u7ea6\u675f\"\"\"\n    dist_list = distance.pdist(coords)\n    penalty = np.sum(0.1 - dist_list[dist_list &lt; 0.1])\n    return penalty\n\n# 2. \u521b\u5efa\u533a\u57df\u548c\u95ee\u9898\nregion = region_from_points([[0,0], [1,0], [1,1], [0,1]])\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=5,\n    region=region,\n    constraints=[constraint]\n)\n\n# 3. \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# 4. \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(100)\n\n# 5. \u5206\u6790\u7ed3\u679c\nprint(f\"\u6700\u7ec8\u79cd\u7fa4\u5f62\u72b6: {result.shape}\")\nprint(f\"\u76ee\u6807\u51fd\u65701\u503c: {optimizer.values_P[0]}\")\nprint(f\"\u76ee\u6807\u51fd\u65702\u503c: {optimizer.values_P[1]}\")\n\n# 6. \u627e\u5230\u5e15\u7d2f\u6258\u524d\u6cbf\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_front = result[fronts[0]]  # \u7b2c\u4e00\u4e2a\u524d\u6cbf\u5c31\u662f\u5e15\u7d2f\u6258\u524d\u6cbf\nprint(f\"\u5e15\u7d2f\u6258\u524d\u6cbf\u89e3\u6570\u91cf: {len(pareto_front)}\")\n</code></pre>"},{"location":"zh/examples/","title":"\u793a\u4f8b\u4ee3\u7801","text":"<p>\u26a0\ufe0f \u91cd\u8981\u63d0\u793a: \u672c\u6587\u6863\u662f\u57fa\u4e8e\u6e90\u7801\u5206\u6790\u7531AI\u751f\u6210\u7684\u3002\u867d\u7136\u6211\u4eec\u52aa\u529b\u786e\u4fdd\u51c6\u786e\u6027\uff0c\u4f46\u4ecd\u53ef\u80fd\u5b58\u5728\u4e0d\u4e00\u81f4\u6216\u95ee\u9898\u3002\u6211\u4eec\u6b63\u5728\u79ef\u6781\u6539\u8fdb\u548c\u9a8c\u8bc1\u6240\u6709\u5185\u5bb9\u3002\u5982\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u53ca\u65f6\u62a5\u544a\u3002</p>"},{"location":"zh/examples/#_2","title":"\u57fa\u7840\u793a\u4f8b","text":""},{"location":"zh/examples/#1","title":"1. \u7b80\u5355\u77e9\u5f62\u533a\u57df\u4f18\u5316","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# \u5b9a\u4e49\u77e9\u5f62\u533a\u57df\nregion = region_from_range(0, 10, 0, 5)\n\n# \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef objective_1(coords):\n    \"\"\"\u6700\u5927\u5316x\u5750\u6807\u548c\"\"\"\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    \"\"\"\u6700\u5927\u5316y\u5750\u6807\u548c\"\"\"\n    return np.sum(coords[:, 1])\n\n# \u521b\u5efa\u95ee\u9898\uff08\u652f\u6301\u591a\u4e2a\u76ee\u6807\u51fd\u6570\uff0c\u4ee5\u4e0b\u4e3a2\u76ee\u6807\u793a\u4f8b\uff09\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=8,\n    region=region\n)\n\n# \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(500)\n\n# \u53ef\u89c6\u5316\u7ed3\u679c\nplt.figure(figsize=(12, 5))\n\n# \u7ed8\u5236\u6700\u7ec8\u79cd\u7fa4\nplt.subplot(1, 2, 1)\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Final Population')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.grid(True)\n\n# \u7ed8\u5236\u76ee\u6807\u51fd\u6570\u503c\nplt.subplot(1, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Objective Function Values')\nplt.xlabel('Objective 1')\nplt.ylabel('Objective 2')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"zh/examples/#2","title":"2. \u5e26\u7ea6\u675f\u7684\u591a\u8fb9\u5f62\u533a\u57df\u4f18\u5316","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# \u5b9a\u4e49\u591a\u8fb9\u5f62\u533a\u57df\nregion = region_from_points([\n    [0, 0],\n    [2, 0],\n    [3, 1],\n    [2, 2],\n    [0, 2],\n    [-1, 1]\n])\n\n# \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef objective_1(coords):\n    \"\"\"\u6700\u5927\u5316\u5230\u539f\u70b9\u7684\u8ddd\u79bb\"\"\"\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    return np.mean(distances)\n\ndef objective_2(coords):\n    \"\"\"\u6700\u5927\u5316\u70b9\u4e4b\u95f4\u7684\u5206\u6563\u5ea6\"\"\"\n    return np.std(coords[:, 0]) + np.std(coords[:, 1])\n\n# \u5b9a\u4e49\u7ea6\u675f\u6761\u4ef6\ndef constraint_min_spacing(coords):\n    \"\"\"\u6700\u5c0f\u95f4\u8ddd\u7ea6\u675f\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 0.5\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_max_spacing(coords):\n    \"\"\"\u6700\u5927\u95f4\u8ddd\u7ea6\u675f\"\"\"\n    dist_list = distance.pdist(coords)\n    max_spacing = 3.0\n    violations = dist_list[dist_list &gt; max_spacing] - max_spacing\n    return np.sum(violations)\n\n# \u521b\u5efa\u95ee\u9898\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=6,\n    region=region,\n    constraints=[constraint_min_spacing, constraint_max_spacing]\n)\n\n# \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=30,\n    prob_crs=0.7,\n    prob_mut=0.05\n)\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(800)\n\n# \u53ef\u89c6\u5316\u7ed3\u679c\nplt.figure(figsize=(15, 5))\n\n# \u7ed8\u5236\u533a\u57df\u548c\u6700\u7ec8\u79cd\u7fa4\nplt.subplot(1, 3, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='gray', ec='black', label='Region')\n\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Final Population in Region')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u76ee\u6807\u51fd\u6570\u503c\nplt.subplot(1, 3, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Objective Function Values')\nplt.xlabel('Objective 1 (Mean Distance)')\nplt.ylabel('Objective 2 (Spread)')\nplt.grid(True)\n\n# \u7ed8\u5236\u4f18\u5316\u5386\u53f2\nplt.subplot(1, 3, 3)\nbest_obj1 = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_obj2 = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_obj1, label='Best Objective 1')\nplt.plot(best_obj2, label='Best Objective 2')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"zh/examples/#_3","title":"\u9ad8\u7ea7\u793a\u4f8b","text":""},{"location":"zh/examples/#3","title":"3. \u98ce\u529b\u53d1\u7535\u673a\u5e03\u5c40\u4f18\u5316","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# \u5b9a\u4e49\u98ce\u573a\u533a\u57df\uff08\u4e0d\u89c4\u5219\u591a\u8fb9\u5f62\uff09\nregion = region_from_points([\n    [0, 0],\n    [5, 0],\n    [8, 2],\n    [7, 5],\n    [4, 6],\n    [1, 4],\n    [-1, 2]\n])\n\n# \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef objective_power_production(coords):\n    \"\"\"\u6700\u5927\u5316\u603b\u53d1\u7535\u91cf\uff08\u7b80\u5316\u6a21\u578b\uff09\"\"\"\n    # \u5047\u8bbe\u53d1\u7535\u91cf\u4e0e\u5230\u4e2d\u5fc3\u70b9\u7684\u8ddd\u79bb\u6210\u53cd\u6bd4\n    center = np.array([3.5, 3])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    power = np.sum(1 / (1 + distances))\n    return power\n\ndef objective_cost(coords):\n    \"\"\"\u6700\u5c0f\u5316\u603b\u6210\u672c\uff08\u7b80\u5316\u6a21\u578b\uff09\"\"\"\n    # \u5047\u8bbe\u6210\u672c\u4e0e\u603b\u8ddd\u79bb\u6210\u6b63\u6bd4\n    total_distance = np.sum(np.sqrt(np.sum(coords**2, axis=1)))\n    return -total_distance  # \u8d1f\u53f7\u56e0\u4e3a\u6211\u4eec\u8981\u6700\u5927\u5316\n\n# \u5b9a\u4e49\u7ea6\u675f\u6761\u4ef6\ndef constraint_turbine_spacing(coords):\n    \"\"\"\u98ce\u529b\u53d1\u7535\u673a\u6700\u5c0f\u95f4\u8ddd\u7ea6\u675f\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 2.0  # \u6700\u5c0f\u95f4\u8ddd2\u4e2a\u5355\u4f4d\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_boundary_distance(coords):\n    \"\"\"\u8fb9\u754c\u8ddd\u79bb\u7ea6\u675f\"\"\"\n    # \u786e\u4fdd\u6240\u6709\u70b9\u8ddd\u79bb\u8fb9\u754c\u81f3\u5c110.5\u4e2a\u5355\u4f4d\n    boundary_distance = 0.5\n    violations = 0\n\n    for point in coords:\n        # \u8ba1\u7b97\u70b9\u5230\u8fb9\u754c\u7684\u8ddd\u79bb\uff08\u7b80\u5316\u8ba1\u7b97\uff09\n        x, y = point\n        if x &lt; boundary_distance or y &lt; boundary_distance:\n            violations += boundary_distance - min(x, y)\n        if x &gt; 8 - boundary_distance or y &gt; 6 - boundary_distance:\n            violations += max(0, x - (8 - boundary_distance)) + max(0, y - (6 - boundary_distance))\n\n    return violations\n\n# \u521b\u5efa\u95ee\u9898\nproblem = Problem(\n    objectives=[objective_power_production, objective_cost],\n    n_points=12,  # 12\u53f0\u98ce\u529b\u53d1\u7535\u673a\n    region=region,\n    constraints=[constraint_turbine_spacing, constraint_boundary_distance]\n)\n\n# \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=50,\n    prob_crs=0.8,\n    prob_mut=0.02\n)\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(1000)\n\n# \u53ef\u89c6\u5316\u7ed3\u679c\nplt.figure(figsize=(15, 10))\n\n# \u7ed8\u5236\u98ce\u573a\u533a\u57df\u548c\u6700\u4f18\u89e3\nplt.subplot(2, 2, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='lightblue', ec='blue', label='Wind Farm Area')\n\n# \u627e\u5230\u5e15\u7d2f\u6258\u6700\u4f18\u89e3\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_solutions = result[fronts[0]]\n\n# \u7ed8\u5236\u5e15\u7d2f\u6258\u6700\u4f18\u89e3\nfor i, solution in enumerate(pareto_solutions):\n    plt.scatter(solution[:, 0], solution[:, 1], \n               c=f'C{i}', marker='o', s=100, alpha=0.7, \n               label=f'Solution {i+1}')\n\nplt.title('Wind Turbine Layout - Pareto Optimal Solutions')\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u76ee\u6807\u51fd\u6570\u503c\nplt.subplot(2, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1], alpha=0.6, label='All Solutions')\nplt.scatter(optimizer.values_P[0][fronts[0]], optimizer.values_P[1][fronts[0]], \n           c='red', s=100, label='Pareto Front')\nplt.title('Objective Function Space')\nplt.xlabel('Power Production')\nplt.ylabel('Cost (negative)')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u4f18\u5316\u5386\u53f2\nplt.subplot(2, 2, 3)\nbest_power = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_cost = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_power, label='Best Power Production')\nplt.plot(best_cost, label='Best Cost')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u6536\u655b\u6027\u5206\u6790\nplt.subplot(2, 2, 4)\navg_power = [np.mean(vals[0]) for vals in optimizer.values_history]\navg_cost = [np.mean(vals[1]) for vals in optimizer.values_history]\nplt.plot(avg_power, label='Average Power Production')\nplt.plot(avg_cost, label='Average Cost')\nplt.title('Population Average History')\nplt.xlabel('Generation')\nplt.ylabel('Average Objective Value')\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# \u8f93\u51fa\u6700\u4f18\u89e3\u4fe1\u606f\nprint(f\"\u627e\u5230 {len(pareto_solutions)} \u4e2a\u5e15\u7d2f\u6258\u6700\u4f18\u89e3\")\nprint(f\"\u6700\u4f73\u53d1\u7535\u91cf: {np.max(optimizer.values_P[0]):.4f}\")\nprint(f\"\u6700\u4f73\u6210\u672c: {np.max(optimizer.values_P[1]):.4f}\")\n</code></pre>"},{"location":"zh/examples/#4","title":"4. \u4f20\u611f\u5668\u7f51\u7edc\u90e8\u7f72\u4f18\u5316","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# \u5b9a\u4e49\u76d1\u63a7\u533a\u57df\nregion = region_from_range(0, 20, 0, 15)\n\n# \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef objective_coverage(coords):\n    \"\"\"\u6700\u5927\u5316\u8986\u76d6\u9762\u79ef\"\"\"\n    # \u7b80\u5316\u7684\u8986\u76d6\u6a21\u578b\uff1a\u6bcf\u4e2a\u4f20\u611f\u5668\u8986\u76d6\u534a\u5f84\u4e3a3\u7684\u5706\u5f62\u533a\u57df\n    coverage_radius = 3.0\n\n    # \u751f\u6210\u7f51\u683c\u70b9\u6765\u8bc4\u4f30\u8986\u76d6\n    x_grid, y_grid = np.meshgrid(np.linspace(0, 20, 50), np.linspace(0, 15, 40))\n    grid_points = np.column_stack([x_grid.ravel(), y_grid.ravel()])\n\n    covered_points = 0\n    for grid_point in grid_points:\n        distances = np.sqrt(np.sum((coords - grid_point)**2, axis=1))\n        if np.any(distances &lt;= coverage_radius):\n            covered_points += 1\n\n    return covered_points / len(grid_points)  # \u8986\u76d6\u7387\n\ndef objective_energy_efficiency(coords):\n    \"\"\"\u6700\u5927\u5316\u80fd\u91cf\u6548\u7387\uff08\u6700\u5c0f\u5316\u603b\u4f20\u8f93\u8ddd\u79bb\uff09\"\"\"\n    # \u5047\u8bbe\u6709\u4e00\u4e2a\u4e2d\u5fc3\u8282\u70b9\u5728(10, 7.5)\n    center = np.array([10, 7.5])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    total_distance = np.sum(distances)\n    return -total_distance  # \u8d1f\u53f7\u56e0\u4e3a\u6211\u4eec\u8981\u6700\u5927\u5316\n\n# \u5b9a\u4e49\u7ea6\u675f\u6761\u4ef6\ndef constraint_sensor_spacing(coords):\n    \"\"\"\u4f20\u611f\u5668\u6700\u5c0f\u95f4\u8ddd\u7ea6\u675f\"\"\"\n    dist_list = distance.pdist(coords)\n    min_spacing = 2.0\n    violations = min_spacing - dist_list[dist_list &lt; min_spacing]\n    return np.sum(violations)\n\ndef constraint_battery_life(coords):\n    \"\"\"\u7535\u6c60\u5bff\u547d\u7ea6\u675f\uff08\u57fa\u4e8e\u8ddd\u79bb\u4e2d\u5fc3\u8282\u70b9\u7684\u8ddd\u79bb\uff09\"\"\"\n    center = np.array([10, 7.5])\n    distances = np.sqrt(np.sum((coords - center)**2, axis=1))\n    max_distance = 12.0  # \u6700\u5927\u4f20\u8f93\u8ddd\u79bb\n    violations = distances[distances &gt; max_distance] - max_distance\n    return np.sum(violations)\n\n# \u521b\u5efa\u95ee\u9898\nproblem = Problem(\n    objectives=[objective_coverage, objective_energy_efficiency],\n    n_points=8,  # 8\u4e2a\u4f20\u611f\u5668\n    region=region,\n    constraints=[constraint_sensor_spacing, constraint_battery_life]\n)\n\n# \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=40,\n    prob_crs=0.6,\n    prob_mut=0.03\n)\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(600)\n\n# \u53ef\u89c6\u5316\u7ed3\u679c\nplt.figure(figsize=(16, 12))\n\n# \u7ed8\u5236\u76d1\u63a7\u533a\u57df\u548c\u4f20\u611f\u5668\u90e8\u7f72\nplt.subplot(2, 3, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.1, fc='lightgreen', ec='green', label='Monitoring Area')\n\n# \u627e\u5230\u5e15\u7d2f\u6258\u6700\u4f18\u89e3\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_solutions = result[fronts[0]]\n\n# \u7ed8\u5236\u6700\u4f18\u89e3\nbest_solution = pareto_solutions[0]  # \u9009\u62e9\u7b2c\u4e00\u4e2a\u5e15\u7d2f\u6258\u89e3\nplt.scatter(best_solution[:, 0], best_solution[:, 1], \n           c='red', marker='s', s=200, label='Sensors')\n\n# \u7ed8\u5236\u8986\u76d6\u8303\u56f4\ncoverage_radius = 3.0\nfor sensor in best_solution:\n    circle = plt.Circle(sensor, coverage_radius, alpha=0.2, fc='blue')\n    plt.gca().add_patch(circle)\n\n# \u7ed8\u5236\u4e2d\u5fc3\u8282\u70b9\nplt.scatter(10, 7.5, c='black', marker='*', s=300, label='Center Node')\n\nplt.title('Sensor Network Deployment')\nplt.xlabel('X Coordinate')\nplt.ylabel('Y Coordinate')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u76ee\u6807\u51fd\u6570\u503c\nplt.subplot(2, 3, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1], alpha=0.6, label='All Solutions')\nplt.scatter(optimizer.values_P[0][fronts[0]], optimizer.values_P[1][fronts[0]], \n           c='red', s=100, label='Pareto Front')\nplt.title('Objective Function Space')\nplt.xlabel('Coverage Rate')\nplt.ylabel('Energy Efficiency')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u4f18\u5316\u5386\u53f2\nplt.subplot(2, 3, 3)\nbest_coverage = [np.max(vals[0]) for vals in optimizer.values_history]\nbest_energy = [np.max(vals[1]) for vals in optimizer.values_history]\nplt.plot(best_coverage, label='Best Coverage')\nplt.plot(best_energy, label='Best Energy Efficiency')\nplt.title('Optimization History')\nplt.xlabel('Generation')\nplt.ylabel('Best Objective Value')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u79cd\u7fa4\u591a\u6837\u6027\nplt.subplot(2, 3, 4)\ndiversity_coverage = [np.std(vals[0]) for vals in optimizer.values_history]\ndiversity_energy = [np.std(vals[1]) for vals in optimizer.values_history]\nplt.plot(diversity_coverage, label='Coverage Diversity')\nplt.plot(diversity_energy, label='Energy Diversity')\nplt.title('Population Diversity')\nplt.xlabel('Generation')\nplt.ylabel('Standard Deviation')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u6536\u655b\u6027\u5206\u6790\nplt.subplot(2, 3, 5)\navg_coverage = [np.mean(vals[0]) for vals in optimizer.values_history]\navg_energy = [np.mean(vals[1]) for vals in optimizer.values_history]\nplt.plot(avg_coverage, label='Average Coverage')\nplt.plot(avg_energy, label='Average Energy Efficiency')\nplt.title('Population Average')\nplt.xlabel('Generation')\nplt.ylabel('Average Objective Value')\nplt.legend()\nplt.grid(True)\n\n# \u7ed8\u5236\u5e15\u7d2f\u6258\u524d\u6cbf\nplt.subplot(2, 3, 6)\npareto_coverage = optimizer.values_P[0][fronts[0]]\npareto_energy = optimizer.values_P[1][fronts[0]]\nplt.scatter(pareto_coverage, pareto_energy, c='red', s=100)\nplt.title('Pareto Front')\nplt.xlabel('Coverage Rate')\nplt.ylabel('Energy Efficiency')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n# \u8f93\u51fa\u7ed3\u679c\u7edf\u8ba1\nprint(f\"\u4f20\u611f\u5668\u7f51\u7edc\u90e8\u7f72\u4f18\u5316\u5b8c\u6210\")\nprint(f\"\u627e\u5230 {len(pareto_solutions)} \u4e2a\u5e15\u7d2f\u6258\u6700\u4f18\u89e3\")\nprint(f\"\u6700\u4f73\u8986\u76d6\u7387: {np.max(optimizer.values_P[0]):.4f}\")\nprint(f\"\u6700\u4f73\u80fd\u91cf\u6548\u7387: {np.max(optimizer.values_P[1]):.4f}\")\n</code></pre>"},{"location":"zh/examples/#_4","title":"\u81ea\u5b9a\u4e49\u7b97\u5b50\u793a\u4f8b","text":""},{"location":"zh/examples/#5","title":"5. \u81ea\u5b9a\u4e49\u4ea4\u53c9\u548c\u53d8\u5f02\u7b97\u5b50","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_range\n\n# \u5b9a\u4e49\u81ea\u5b9a\u4e49\u4ea4\u53c9\u7b97\u5b50\ndef custom_crossover(population, prob_crs):\n    \"\"\"\u81ea\u5b9a\u4e49\u4ea4\u53c9\u7b97\u5b50\uff1a\u57fa\u4e8e\u8ddd\u79bb\u7684\u4ea4\u53c9\"\"\"\n    n_points = population.shape[1]\n\n    for i in range(0, len(population), 2):\n        if np.random.rand() &lt; prob_crs:\n            # \u8ba1\u7b97\u4e24\u4e2a\u7236\u4ee3\u4e4b\u95f4\u7684\u8ddd\u79bb\n            parent1 = population[i]\n            parent2 = population[i+1]\n\n            # \u57fa\u4e8e\u8ddd\u79bb\u9009\u62e9\u4ea4\u53c9\u70b9\n            distances = np.sqrt(np.sum((parent1 - parent2)**2, axis=1))\n            cross_points = distances &gt; np.median(distances)\n\n            # \u4ea4\u6362\u9009\u4e2d\u7684\u70b9\n            population[i, cross_points] = parent2[cross_points]\n            population[i+1, cross_points] = parent1[cross_points]\n\n    return population\n\n# \u5b9a\u4e49\u81ea\u5b9a\u4e49\u53d8\u5f02\u7b97\u5b50\ndef custom_mutation(population, prob_mut, region):\n    \"\"\"\u81ea\u5b9a\u4e49\u53d8\u5f02\u7b97\u5b50\uff1a\u9ad8\u65af\u53d8\u5f02\"\"\"\n    from coords_nsga2.spatial import create_points_in_polygon\n\n    mutation_mask = np.random.random(population.shape[:-1]) &lt; prob_mut\n\n    for i in range(len(population)):\n        for j in range(population.shape[1]):\n            if mutation_mask[i, j]:\n                # \u9ad8\u65af\u53d8\u5f02\n                current_point = population[i, j]\n                new_point = current_point + np.random.normal(0, 0.5, 2)\n\n                # \u786e\u4fdd\u65b0\u70b9\u5728\u533a\u57df\u5185\n                if region.contains(plt.matplotlib.patches.Circle(new_point, 0)):\n                    population[i, j] = new_point\n                else:\n                    # \u5982\u679c\u4e0d\u5728\u533a\u57df\u5185\uff0c\u91cd\u65b0\u751f\u6210\n                    new_points = create_points_in_polygon(region, 1)\n                    population[i, j] = new_points[0]\n\n    return population\n\n# \u5b9a\u4e49\u533a\u57df\u548c\u76ee\u6807\u51fd\u6570\nregion = region_from_range(0, 10, 0, 10)\n\ndef objective_1(coords):\n    return np.sum(coords[:, 0])\n\ndef objective_2(coords):\n    return np.sum(coords[:, 1])\n\n# \u521b\u5efa\u95ee\u9898\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=5,\n    region=region\n)\n\n# \u521b\u5efa\u4f18\u5316\u5668\u5e76\u66ff\u6362\u81ea\u5b9a\u4e49\u7b97\u5b50\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# \u66ff\u6362\u4e3a\u81ea\u5b9a\u4e49\u7b97\u5b50\noptimizer.crossover = custom_crossover\noptimizer.mutation = custom_mutation\n\n# \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(300)\n\n# \u53ef\u89c6\u5316\u7ed3\u679c\nplt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nx, y = region.exterior.xy\nplt.fill(x, y, alpha=0.2, fc='gray', ec='black')\n\nfor i in range(len(result)):\n    plt.scatter(result[i, :, 0], result[i, :, 1], alpha=0.6)\nplt.title('Custom Operators - Final Population')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.grid(True)\n\nplt.subplot(1, 2, 2)\nplt.scatter(optimizer.values_P[0], optimizer.values_P[1])\nplt.title('Custom Operators - Objective Values')\nplt.xlabel('Objective 1')\nplt.ylabel('Objective 2')\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>\u8fd9\u4e9b\u793a\u4f8b\u5c55\u793a\u4e86Coords-NSGA2\u5e93\u7684\u5404\u79cd\u7528\u6cd5\uff0c\u4ece\u57fa\u7840\u7684\u591a\u76ee\u6807\u4f18\u5316\u5230\u590d\u6742\u7684\u5b9e\u9645\u5e94\u7528\u573a\u666f\u3002\u60a8\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u4fee\u6539\u8fd9\u4e9b\u793a\u4f8b\u3002</p>"},{"location":"zh/","title":"\u9996\u9875","text":""},{"location":"zh/#coords-nsga2","title":"\u6b22\u8fce\u4f7f\u7528 Coords-NSGA2","text":"<p>\u26a0\ufe0f \u91cd\u8981\u63d0\u793a: \u672c\u6587\u6863\u662f\u57fa\u4e8e\u6e90\u7801\u5206\u6790\u7531AI\u751f\u6210\u7684\u3002\u867d\u7136\u6211\u4eec\u52aa\u529b\u786e\u4fdd\u51c6\u786e\u6027\uff0c\u4f46\u4ecd\u53ef\u80fd\u5b58\u5728\u4e0d\u4e00\u81f4\u6216\u95ee\u9898\u3002\u6211\u4eec\u6b63\u5728\u79ef\u6781\u6539\u8fdb\u548c\u9a8c\u8bc1\u6240\u6709\u5185\u5bb9\u3002\u5982\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u53ca\u65f6\u62a5\u544a\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a\u57fa\u4e8e Python \u5b9e\u73b0\u7684\u9488\u5bf9\u5750\u6807\u7ec4\u5408\u7684\u591a\u76ee\u6807\u4f18\u5316\u7b97\u6cd5\u5e93\uff0c\u57fa\u4e8e NSGA-II \u65b9\u6cd5\u6539\u8fdb\u3002</p>"},{"location":"zh/#_1","title":"\u6982\u8ff0","text":"<p>Coords-NSGA2 \u662f\u4e00\u4e2a\u4e13\u95e8\u4e3a\u5750\u6807\u70b9\u5e03\u5c40\u4f18\u5316\u800c\u8bbe\u8ba1\u7684Python\u5e93\uff0c\u57fa\u4e8e\u7ecf\u5178\u7684NSGA-II\uff08\u975e\u652f\u914d\u6392\u5e8f\u9057\u4f20\u7b97\u6cd5II\uff09\u7b97\u6cd5\u6539\u8fdb\u800c\u6765\u3002</p>"},{"location":"zh/#_2","title":"\u4e3b\u8981\u7279\u6027","text":"<ul> <li>\u5750\u6807\u4f18\u5316\u4e13\u7528\uff1a\u4e13\u95e8\u4e3a\u4f18\u5316\u5750\u6807\u70b9\u5e03\u5c40\u800c\u8bbe\u8ba1</li> <li>\u4e13\u4e1a\u7ea6\u675f\u6761\u4ef6\uff1a\u5185\u7f6e\u652f\u6301\u70b9\u95f4\u8ddd\u3001\u8fb9\u754c\u9650\u5236\u548c\u81ea\u5b9a\u4e49\u7ea6\u675f</li> <li>\u5b9a\u5236\u9057\u4f20\u7b97\u5b50\uff1a\u4e13\u95e8\u4f5c\u7528\u4e8e\u5750\u6807\u70b9\u7684\u4ea4\u53c9\u548c\u53d8\u5f02\u7b97\u5b50</li> <li>\u591a\u76ee\u6807\u4f18\u5316\uff1a\u57fa\u4e8e\u6210\u719f\u7684NSGA-II\u7b97\u6cd5</li> <li>\u7075\u6d3b\u533a\u57df\u5b9a\u4e49\uff1a\u652f\u6301\u591a\u8fb9\u5f62\u548c\u77e9\u5f62\u533a\u57df</li> <li>\u8f7b\u91cf\u7ea7\u53ef\u6269\u5c55\uff1a\u6613\u4e8e\u81ea\u5b9a\u4e49\u7b97\u5b50\u548c\u7ea6\u675f\u6761\u4ef6</li> <li>\u8fdb\u5ea6\u8ddf\u8e2a\uff1a\u5185\u7f6e\u8fdb\u5ea6\u6761\u548c\u4f18\u5316\u5386\u53f2\u8bb0\u5f55</li> <li>\u4fdd\u5b58/\u52a0\u8f7d\u529f\u80fd\uff1a\u4fdd\u5b58\u548c\u6062\u590d\u4f18\u5316\u72b6\u6001</li> </ul>"},{"location":"zh/#_3","title":"\u5feb\u901f\u5f00\u59cb","text":"<ul> <li>\u5b89\u88c5\uff1a\u8bf7\u53c2\u9605 \u5b89\u88c5\u6307\u5357</li> <li>\u4f7f\u7528\uff1a\u8be6\u7ec6\u6559\u7a0b\u8bf7\u53c2\u9605 \u4f7f\u7528\u6307\u5357</li> <li>API\u53c2\u8003\uff1a\u8bf7\u53c2\u9605 API\u6587\u6863</li> <li>\u793a\u4f8b\uff1a\u8bf7\u53c2\u9605 \u793a\u4f8b\u4ee3\u7801</li> </ul>"},{"location":"zh/#_4","title":"\u5e94\u7528\u573a\u666f","text":"<ul> <li>\u98ce\u529b\u53d1\u7535\u673a\u5e03\u5c40\u4f18\u5316</li> <li>\u4f20\u611f\u5668\u7f51\u7edc\u90e8\u7f72</li> <li>\u8bbe\u65bd\u9009\u5740\u95ee\u9898</li> <li>\u673a\u5668\u4eba\u8def\u5f84\u89c4\u5212</li> <li>\u5176\u4ed6\u9700\u8981\u4f18\u5316\u5750\u6807\u70b9\u5e03\u5c40\u7684\u573a\u666f</li> </ul>"},{"location":"zh/#_5","title":"\u7cfb\u7edf\u8981\u6c42","text":"<ul> <li>Python 3.9+</li> <li>NumPy &gt;= 1.23</li> <li>tqdm &gt;= 4</li> <li>Shapely &gt;= 2</li> <li>SciPy (\u53ef\u9009\uff0c\u7528\u4e8e\u8ddd\u79bb\u8ba1\u7b97)</li> <li>matplotlib (\u53ef\u9009\uff0c\u7528\u4e8e\u7ed3\u679c\u53ef\u89c6\u5316)</li> </ul>"},{"location":"zh/install/","title":"\u5b89\u88c5\u6307\u5357","text":"<p>\u26a0\ufe0f \u91cd\u8981\u63d0\u793a: \u672c\u6587\u6863\u662f\u57fa\u4e8e\u6e90\u7801\u5206\u6790\u7531AI\u751f\u6210\u7684\u3002\u867d\u7136\u6211\u4eec\u52aa\u529b\u786e\u4fdd\u51c6\u786e\u6027\uff0c\u4f46\u4ecd\u53ef\u80fd\u5b58\u5728\u4e0d\u4e00\u81f4\u6216\u95ee\u9898\u3002\u6211\u4eec\u6b63\u5728\u79ef\u6781\u6539\u8fdb\u548c\u9a8c\u8bc1\u6240\u6709\u5185\u5bb9\u3002\u5982\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u53ca\u65f6\u62a5\u544a\u3002</p>"},{"location":"zh/install/#_2","title":"\u4e2d\u6587\u5b89\u88c5\u6307\u5357","text":""},{"location":"zh/install/#_3","title":"\u7cfb\u7edf\u8981\u6c42","text":"<ul> <li>Python 3.9 \u6216\u66f4\u9ad8\u7248\u672c</li> <li>pip \u5305\u7ba1\u7406\u5668</li> </ul>"},{"location":"zh/install/#pypi","title":"\u4ece PyPI \u5b89\u88c5\uff08\u63a8\u8350\uff09","text":"<pre><code>pip install coords-nsga2\n</code></pre>"},{"location":"zh/install/#_4","title":"\u4ece\u6e90\u7801\u5b89\u88c5","text":"<p>\u5982\u679c\u60a8\u60f3\u5b89\u88c5\u6700\u65b0\u5f00\u53d1\u7248\u672c\u6216\u4fee\u6539\u4ee3\u7801\uff1a</p> <pre><code>git clone https://github.com/ZXF1001/coords-nsga2.git\ncd coords-nsga2\npip install -e .\n</code></pre>"},{"location":"zh/install/#_5","title":"\u5f00\u53d1\u73af\u5883\u5b89\u88c5","text":"<p>\u5982\u679c\u60a8\u60f3\u53c2\u4e0e\u5f00\u53d1\uff1a</p> <pre><code>git clone https://github.com/ZXF1001/coords-nsga2.git\ncd coords-nsga2\npip install -e \".[test]\"\n</code></pre>"},{"location":"zh/install/#_6","title":"\u9a8c\u8bc1\u5b89\u88c5","text":"<p>\u5b89\u88c5\u5b8c\u6210\u540e\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u9a8c\u8bc1\u5b89\u88c5\uff1a</p> <pre><code>import coords_nsga2\nprint(coords_nsga2.__version__)\n</code></pre>"},{"location":"zh/install/#_7","title":"\u4f9d\u8d56\u5305","text":""},{"location":"zh/install/#_8","title":"\u5fc5\u9700\u4f9d\u8d56","text":"<ul> <li>numpy &gt;= 1.23: \u6570\u503c\u8ba1\u7b97\u5e93</li> <li>tqdm &gt;= 4: \u8fdb\u5ea6\u6761\u663e\u793a</li> <li>shapely &gt;= 2: \u51e0\u4f55\u8ba1\u7b97\u5e93</li> </ul>"},{"location":"zh/install/#_9","title":"\u53ef\u9009\u4f9d\u8d56","text":"<ul> <li>scipy: \u7528\u4e8e\u8ddd\u79bb\u8ba1\u7b97\u548c\u5176\u4ed6\u79d1\u5b66\u8ba1\u7b97</li> <li>matplotlib: \u7528\u4e8e\u7ed3\u679c\u53ef\u89c6\u5316</li> </ul>"},{"location":"zh/install/#_10","title":"\u5f00\u53d1\u4f9d\u8d56","text":"<ul> <li>pytest &gt;= 8.2: \u6d4b\u8bd5\u6846\u67b6</li> <li>pytest-cov &gt;= 5: \u6d4b\u8bd5\u8986\u76d6\u7387</li> <li>coverage[toml] &gt;= 7.5: \u4ee3\u7801\u8986\u76d6\u7387</li> <li>hypothesis &gt;= 6.100: \u5c5e\u6027\u6d4b\u8bd5</li> <li>ruff &gt;= 0.11: \u4ee3\u7801\u683c\u5f0f\u5316\u548c\u68c0\u67e5</li> <li>pre-commit &gt;= 3.7: Git\u94a9\u5b50</li> </ul>"},{"location":"zh/usage/","title":"\u4f7f\u7528\u6307\u5357 / Usage Guide","text":"<p>\u26a0\ufe0f \u91cd\u8981\u63d0\u793a: \u672c\u6587\u6863\u662f\u57fa\u4e8e\u6e90\u7801\u5206\u6790\u7531AI\u751f\u6210\u7684\u3002\u867d\u7136\u6211\u4eec\u52aa\u529b\u786e\u4fdd\u51c6\u786e\u6027\uff0c\u4f46\u4ecd\u53ef\u80fd\u5b58\u5728\u4e0d\u4e00\u81f4\u6216\u95ee\u9898\u3002\u6211\u4eec\u6b63\u5728\u79ef\u6781\u6539\u8fdb\u548c\u9a8c\u8bc1\u6240\u6709\u5185\u5bb9\u3002\u5982\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u53ca\u65f6\u62a5\u544a\u3002</p>"},{"location":"zh/usage/#_1","title":"\u4e2d\u6587\u4f7f\u7528\u6307\u5357","text":""},{"location":"zh/usage/#_2","title":"\u57fa\u672c\u6982\u5ff5","text":"<p>Coords-NSGA2 \u5e93\u7684\u6838\u5fc3\u6982\u5ff5\u5305\u62ec\uff1a</p> <ol> <li>Problem\uff08\u95ee\u9898\uff09\uff1a\u5b9a\u4e49\u4f18\u5316\u95ee\u9898\u7684\u76ee\u6807\u51fd\u6570\u3001\u7ea6\u675f\u6761\u4ef6\u548c\u641c\u7d22\u533a\u57df</li> <li>CoordsNSGA2\uff08\u4f18\u5316\u5668\uff09\uff1a\u6267\u884cNSGA-II\u7b97\u6cd5\u7684\u4f18\u5316\u5668</li> <li>Region\uff08\u533a\u57df\uff09\uff1a\u5b9a\u4e49\u5750\u6807\u70b9\u7684\u6709\u6548\u641c\u7d22\u7a7a\u95f4</li> <li>Constraints\uff08\u7ea6\u675f\uff09\uff1a\u9650\u5236\u89e3\u7684\u53ef\u884c\u6027\u7684\u6761\u4ef6</li> </ol>"},{"location":"zh/usage/#_3","title":"\u5feb\u901f\u5f00\u59cb\u793a\u4f8b","text":"<p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u5b8c\u6574\u7684\u4f7f\u7528\u793a\u4f8b\uff0c\u6f14\u793a\u5982\u4f55\u4f18\u531610\u4e2a\u5750\u6807\u70b9\u7684\u5e03\u5c40\uff1a</p> <pre><code>import numpy as np\nfrom scipy.spatial import distance\nfrom coords_nsga2 import CoordsNSGA2, Problem\nfrom coords_nsga2.spatial import region_from_points\n\n# 1. \u5b9a\u4e49\u4f18\u5316\u533a\u57df\uff08\u591a\u8fb9\u5f62\uff09\nregion = region_from_points([\n    [0, 0],\n    [1, 0],\n    [2, 1],\n    [1, 1],\n])\n\n# 2. \u5b9a\u4e49\u76ee\u6807\u51fd\u6570\ndef objective_1(coords):\n    \"\"\"\u7b2c\u4e00\u4e2a\u76ee\u6807\uff1a\u6700\u5927\u5316\u5750\u6807\u548c\"\"\"\n    return np.sum(coords[:, 0]) + np.sum(coords[:, 1])\n\ndef objective_2(coords):\n    \"\"\"\u7b2c\u4e8c\u4e2a\u76ee\u6807\uff1a\u6700\u5927\u5316\u70b9\u7684\u5206\u5e03\"\"\"\n    return np.std(coords[:, 0]) + np.std(coords[:, 1])\n\n# 3. \u5b9a\u4e49\u7ea6\u675f\u6761\u4ef6\nspacing = 0.05  # \u6700\u5c0f\u95f4\u8ddd\ndef constraint_1(coords):\n    \"\"\"\u7ea6\u675f\uff1a\u70b9\u4e4b\u95f4\u7684\u6700\u5c0f\u95f4\u8ddd\"\"\"\n    dist_list = distance.pdist(coords)\n    penalty_list = spacing - dist_list[dist_list &lt; spacing]\n    return np.sum(penalty_list)\n\n# 4. \u521b\u5efa\u95ee\u9898\u5b9e\u4f8b\uff08\u652f\u6301\u4efb\u610f\u591a\u4e2a\u76ee\u6807\uff09\nproblem = Problem(\n    objectives=[objective_1, objective_2],\n    n_points=10,\n    region=region,\n    constraints=[constraint_1]\n)\n\n# 5. \u521b\u5efa\u4f18\u5316\u5668\noptimizer = CoordsNSGA2(\n    problem=problem,\n    pop_size=20,\n    prob_crs=0.5,\n    prob_mut=0.1\n)\n\n# 6. \u8fd0\u884c\u4f18\u5316\nresult = optimizer.run(1000)\n\n# 7. \u67e5\u770b\u7ed3\u679c\nprint(f\"\u4f18\u5316\u5b8c\u6210\uff01\u7ed3\u679c\u5f62\u72b6: {result.shape}\")\nprint(f\"\u79cd\u7fa4\u5927\u5c0f: {len(result)}\")\nprint(f\"\u6bcf\u4e2a\u89e3\u7684\u5750\u6807\u70b9\u6570: {result.shape[1]}\")\n</code></pre>"},{"location":"zh/usage/#_4","title":"\u533a\u57df\u5b9a\u4e49","text":""},{"location":"zh/usage/#_5","title":"\u4ece\u70b9\u5217\u8868\u521b\u5efa\u591a\u8fb9\u5f62\u533a\u57df","text":"<pre><code>from coords_nsga2.spatial import region_from_points\n\n# \u5b9a\u4e49\u591a\u8fb9\u5f62\u7684\u9876\u70b9\npoints = [\n    [0, 0],\n    [1, 0],\n    [2, 1],\n    [1, 1],\n]\nregion = region_from_points(points)\n</code></pre>"},{"location":"zh/usage/#_6","title":"\u4ece\u5750\u6807\u8303\u56f4\u521b\u5efa\u77e9\u5f62\u533a\u57df","text":"<pre><code>from coords_nsga2.spatial import region_from_range\n\n# \u5b9a\u4e49\u77e9\u5f62\u7684\u8fb9\u754c\nregion = region_from_range(x_min=0, x_max=10, y_min=0, y_max=5)\n</code></pre>"},{"location":"zh/usage/#_7","title":"\u76ee\u6807\u51fd\u6570\u5b9a\u4e49","text":"<p>\u76ee\u6807\u51fd\u6570\u5e94\u8be5\u63a5\u53d7\u4e00\u4e2a\u5f62\u72b6\u4e3a <code>(n_points, 2)</code> \u7684numpy\u6570\u7ec4\u4f5c\u4e3a\u8f93\u5165\uff0c\u8fd4\u56de\u4e00\u4e2a\u6807\u91cf\u503c\uff1a</p> <pre><code>def my_objective(coords):\n    \"\"\"\n    \u53c2\u6570:\n        coords: numpy\u6570\u7ec4\uff0c\u5f62\u72b6\u4e3a(n_points, 2)\n                \u6bcf\u884c\u662f\u4e00\u4e2a\u5750\u6807\u70b9 [x, y]\n\n    \u8fd4\u56de:\n        float: \u76ee\u6807\u51fd\u6570\u503c\n    \"\"\"\n    # \u793a\u4f8b\uff1a\u8ba1\u7b97\u6240\u6709\u70b9\u5230\u539f\u70b9\u7684\u5e73\u5747\u8ddd\u79bb\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    return np.mean(distances)\n</code></pre>"},{"location":"zh/usage/#_8","title":"\u7ea6\u675f\u6761\u4ef6\u5b9a\u4e49","text":"<p>\u7ea6\u675f\u51fd\u6570\u5e94\u8be5\u8fd4\u56de\u8fdd\u53cd\u7ea6\u675f\u7684\u60e9\u7f5a\u503c\u3002\u8fd4\u56de0\u8868\u793a\u6ca1\u6709\u8fdd\u53cd\u7ea6\u675f\uff1a</p> <pre><code>def my_constraint(coords):\n    \"\"\"\n    \u53c2\u6570:\n        coords: numpy\u6570\u7ec4\uff0c\u5f62\u72b6\u4e3a(n_points, 2)\n\n    \u8fd4\u56de:\n        float: \u7ea6\u675f\u8fdd\u53cd\u7684\u60e9\u7f5a\u503c\uff080\u8868\u793a\u65e0\u8fdd\u53cd\uff09\n    \"\"\"\n    # \u793a\u4f8b\uff1a\u786e\u4fdd\u6240\u6709\u70b9\u90fd\u5728\u5355\u4f4d\u5706\u5185\n    distances = np.sqrt(coords[:, 0]**2 + coords[:, 1]**2)\n    violations = distances[distances &gt; 1] - 1\n    return np.sum(violations)\n</code></pre>"},{"location":"zh/usage/#_9","title":"\u4f18\u5316\u5668\u53c2\u6570","text":""},{"location":"zh/usage/#coordsnsga2","title":"CoordsNSGA2 \u53c2\u6570\u8bf4\u660e","text":"<ul> <li><code>problem</code>: Problem\u5b9e\u4f8b</li> <li><code>pop_size</code>: \u79cd\u7fa4\u5927\u5c0f\uff08\u5fc5\u987b\u4e3a\u5076\u6570\uff09</li> <li><code>prob_crs</code>: \u4ea4\u53c9\u6982\u7387\uff080-1\u4e4b\u95f4\uff09</li> <li><code>prob_mut</code>: \u53d8\u5f02\u6982\u7387\uff080-1\u4e4b\u95f4\uff09</li> <li><code>random_seed</code>: \u968f\u673a\u79cd\u5b50\uff08\u7528\u4e8e\u53ef\u91cd\u73b0\u6027\uff09</li> </ul>"},{"location":"zh/usage/#_10","title":"\u53c2\u6570\u8c03\u4f18\u5efa\u8bae","text":"<ul> <li>\u79cd\u7fa4\u5927\u5c0f: \u901a\u5e38\u8bbe\u7f6e\u4e3a20-100\uff0c\u95ee\u9898\u590d\u6742\u65f6\u4f7f\u7528\u66f4\u5927\u7684\u79cd\u7fa4</li> <li>\u4ea4\u53c9\u6982\u7387: \u901a\u5e38\u8bbe\u7f6e\u4e3a0.5-0.9</li> <li>\u53d8\u5f02\u6982\u7387: \u901a\u5e38\u8bbe\u7f6e\u4e3a0.01-0.1</li> <li>\u4ee3\u6570: \u6839\u636e\u95ee\u9898\u590d\u6742\u5ea6\u8bbe\u7f6e\uff0c\u901a\u5e38100-1000\u4ee3</li> </ul>"},{"location":"zh/usage/#_11","title":"\u7ed3\u679c\u5206\u6790","text":"<p>\u4f18\u5316\u5b8c\u6210\u540e\uff0c\u60a8\u53ef\u4ee5\u8bbf\u95ee\u4ee5\u4e0b\u5c5e\u6027\uff1a</p> <pre><code># \u6700\u7ec8\u79cd\u7fa4\nfinal_population = optimizer.P\n\n# \u76ee\u6807\u51fd\u6570\u503c\uff08\u5f62\u72b6: n_objectives \u00d7 pop_size\uff09\nvalues = optimizer.values_P\nvalues1 = values[0]\nvalues2 = values[1]\n\n# \u4f18\u5316\u5386\u53f2\npopulation_history = optimizer.P_history\nvalues_history = optimizer.values_history  # \u5217\u8868\uff0c\u6bcf\u4ee3\u4e00\u4e2a (n_objectives, pop_size) \u6570\u7ec4\n\n# \u627e\u5230\u5e15\u7d2f\u6258\u524d\u6cbf\uff08\u57fa\u4e8e\u6700\u540e\u4e00\u4ee3\u76ee\u6807\u503c\uff09\nfrom coords_nsga2.utils import fast_non_dominated_sort\nfronts = fast_non_dominated_sort(optimizer.values_P)\npareto_front = optimizer.P[fronts[0]]\n</code></pre>"},{"location":"zh/usage/#_12","title":"\u4fdd\u5b58\u548c\u52a0\u8f7d","text":"<pre><code># \u4fdd\u5b58\u4f18\u5316\u72b6\u6001\noptimizer.save(\"optimization_result.npz\")\n\n# \u52a0\u8f7d\u4f18\u5316\u72b6\u6001\noptimizer.load(\"optimization_result.npz\")\n</code></pre>"}]}